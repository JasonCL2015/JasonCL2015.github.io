<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonCui&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/5ad85fa42a4f59ade5d6567b6f5916c1</icon>
  <subtitle>Think And Code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jasoncui.com/"/>
  <updated>2018-07-14T04:44:35.842Z</updated>
  <id>http://jasoncui.com/</id>
  
  <author>
    <name>JasonCui</name>
    <email>13567157290@sohu.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>履历2</title>
    <link href="http://jasoncui.com/2018/07/14/%E5%B1%A5%E5%8E%862/"/>
    <id>http://jasoncui.com/2018/07/14/履历2/</id>
    <published>2018-07-14T04:38:30.000Z</published>
    <updated>2018-07-14T04:44:35.842Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

      
    
    </summary>
    
      <category term="读书" scheme="http://jasoncui.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://jasoncui.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jasoncui.com/2018/07/14/%E5%B1%A5%E5%8E%86/"/>
    <id>http://jasoncui.com/2018/07/14/履历/</id>
    <published>2018-07-14T03:52:16.603Z</published>
    <updated>2018-07-14T04:34:18.566Z</updated>
    
    <content type="html"><![CDATA[<p>title: 履历<br>keywords: ‘读书’<br>date: 2017-10-14 11:25:06<br>password: 26592001<br>categories: 读书<br>tags: 读书</p><p>description:</p><blockquote class="blockquote-center">有人的地方就是江湖</blockquote><a id="more"></a><h2 id="个-人-简-历"><a href="#个-人-简-历" class="headerlink" title="个 人 简 历"></a>个 人 简 历</h2><table><thead><tr><th><strong>姓名：</strong></th><th>崔亮</th><th><strong>性别：</strong></th><th>男</th></tr></thead><tbody><tr><td><strong>年龄：</strong></td><td>32</td><td><strong>籍贯：</strong></td><td>江苏南通</td></tr><tr><td><strong>学历</strong>：</td><td>本科</td><td><strong>工作经验：</strong></td><td>8年</td></tr><tr><td><strong>联系电话：</strong></td><td>13567157290</td><td><strong>电子邮件：</strong></td><td><a href="mailto:cuiliang86@sohu.com" target="_blank" rel="noopener">cuiliang86@sohu.com</a></td></tr></tbody></table><table><thead><tr><th>自我评价</th></tr></thead><tbody><tr><td>1、思路清晰，有独立分析解决问题的能力。 <br>2、工作认真、善于寻找新的编程思路，拥有好奇心和激情，敢于迎接挑战，有充沛的精力投入工作。    <br>3、具备良好的学习、沟通和团队协作能力，能够较快地接收新事物和适应新环境。</td></tr></tbody></table><table><thead><tr><th>求职意向</th><th></th></tr></thead><tbody><tr><td>工作性质：</td><td>全职</td></tr><tr><td>目标职能：</td><td>架构师、技术专家</td></tr><tr><td>目标城市：</td><td>杭州</td></tr></tbody></table><table><thead><tr><th>工作经历</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>2018-4至今</td><td>杭州一骑轻尘信息技术有限公司（卖好车）</td><td>平台技术部</td><td>架构师</td></tr><tr><td>2017-5 至2018-4</td><td>心怡科技股份有限公司</td><td>SAAS 开发部</td><td>资深Java工程师</td></tr><tr><td>2015-3 至 2017-4</td><td>利尔达集团有限公司</td><td>贤芯科技</td><td>研发经理</td></tr><tr><td>2013-6 至 2015-2</td><td>恒生电子股份有限公司</td><td>交易所事业部杭州研发部</td><td>高级 Java 工程师</td></tr><tr><td>2010-7 至 2013-6</td><td>杭州医惠科技有限公司</td><td>护理事业部</td><td>Java 工程师</td></tr></tbody></table><table><thead><tr><th>技能专长</th></tr></thead><tbody><tr><td>1.熟悉常用 RPC 应用框架 Dubbo、Thrift、Hessian，了解分布式系统应用服务治理技术并具备相关项目经验。<br> 2.学习并运用过 Spring 生态圈里的一些 main projects,如 SpringCloud SpringBoot SpringSecurity SpringKafka 等。<br> 3.了解微服务设计，知道一些分布式数据一致性问题的解决方案并自主研发使用过。<br> 4.对业务感知能力强，调研过某行业解决方案，并带队设计研发过一套业务模型系统。  <br>  5.基于 Elasticsearch 搜索引擎，对海量数据做过检索优化。  <br>6.项目运用过 mysql,mongodb,redis 等数据库，了解持久层框架 mybatis,mybatisplus,springData 以及优化方案。 <br>7.知道常用 Linux 命令，熟练掌握基于容器服务的相关运维方案，如 Rancher、K8S，提速团队开发测试效 率。 <br></td></tr></tbody></table><table><thead><tr><th>工作经历</th></tr></thead><tbody><tr><td><strong>项目名称</strong>: BOSS运营平台系统  <br><strong>周期</strong>:2017年7月至今;  <br><strong>使用技术</strong>:SpringBoot + Dubbox + Zookeeper + MySQL + Redis + Disconf等 <br><strong>项目描述</strong>:  BOSS运营平台系统是我司针对仓储商家端研发的运营平台系统，包含订单管理系统(OMS)、运输 管理系统(OTMS)、运营管理系统(OSS),平台管理系统(PMS)。该平台在遵循奇门协议基础上，上游承 接淘宝、天猫等交易平台数据，下游对接WMS，TMS数据，为商家统一管理供应商、仓库、渠道、店铺、商 品，库存等信息。 <br> <strong>责任描述</strong>:  <br> 1，负责项目需求调研分析，功能分解，任务量化分工。<br> 2，负责技术选型，整套系统框架搭建和维护。<br> 3，负责系统基础功能抽象化开发，如灾备任务、定时任务、全局锁、接口幂等性、消息队列等。 <br> 4，负责核心业务功能开发。 <br> 5，负责基础运维工作。 <br><br><br> <strong>项目名称</strong>: 智能电动车管理系统 <br><strong>周期</strong>:2015年11月至2016年10月; <br><strong>使用技术</strong>:SpringBoot + SpringCloud + Zookeeper + KafKa + redis + mongodb等 <br><strong>项目描述</strong>: <br> 智能电车管理系统是我司在物联网应用解决方案下做的代表性产品，在这套系统里我们分为设备连 接平台，协议解析模块，通用业务模型管理模块和定制化业务功能。设备连接平台是基于Netty IO框架的 自主产品，致力于提供高效稳定的异步通信连接，保障硬件设备数据的安全传输。协议解析模块主要负责 设备应用协议配置和解析，与通用业务模型搭配使用，做到any protocol any model快速呈现业务对象原 型，在此基础上做定制化开发。 <br> 项目采用分布式微服务架构设计，利用SpringCloud对于eureka的集成，实现分布式的服务注册中心; 利用zuul+hystrix+feign+jwt定制化功能网关，包括负载均衡、熔断机制、用户鉴权、访问限流等功能; 利用zookeeper+kafka+springcloud bus实现分布式服务配置中心，为分布式系统定制全局锁组件，解决数 据一致性问题。利用Hystrix Dashboard + Turbine搭建了系统监控模块，利用ELK实现日志监控和报警模 块，业务功能模块以RestFul风格设计接口开发，尽量做到幂等性原则。数据存储运用mysql+redis+mongodb， 实现读写分离。 <br> 电车管理系统官网地址:<a href="http://doohan.cn" target="_blank" rel="noopener">http://doohan.cn</a> <br> <strong>责任描述</strong>: <br> 1，负责项目需求调研分析，功能分解，任务量化分工。 <br>2，负责技术选型，整套系统框架搭建和维护。 <br>3，负责基础功能组件开发，如网关熔断处理、鉴权处理、限流功能、全局锁等。 <br>4，负责部分核心业务功能开发。 <br><br><br> <strong>项目名称</strong>: 智慧园区管理系统 <br> <strong>周期</strong>:2015年3月至2015年10月; <br> <strong>使用技术</strong>:SpringMVC + Mybatis + Freemarker + redis等 项目描述: <br><strong>项目描述</strong>: <br> 智慧园区系统是利尔达物联网科技园区内智能化设备的一套解决方案系统，包括园区团购、拼车、 灯控、门禁、快递、场地预约、停车、资金支付等模块。集中将园区智能硬件和软件监控管理相结合，完 成一套园区生活相关的解决方案。系统面向园区办公用户和访客，对园区租户进行统一管理授权，细分每 个楼层办公室的设备控制权限和门禁等，进行访客登记和指引。系统主要利用SpringMVC三层架构，CAS框 架实现SSO，结合Socket通信将园区智能硬件设备进行联网交互，对硬件上报数据进行监控和采集等。 <br> 园区管理地址:<a href="http://app.lierdapark.com/ibuildings2" target="_blank" rel="noopener">http://app.lierdapark.com/ibuildings2</a> <br> <strong>责任描述</strong>: <br> 1，负责项目开发框架搭建和基础组件功能实现，如SSO功能，Socket连接通信等。<br> 2，负责带领小组资金管理系统和门禁系统的开发。 <br><br><br><strong>项目名称：</strong> 上海邮币卡交易中心在线交易系统   <br><strong>周期</strong>：2014年3月至2014年9月；   <br><strong>使用技术</strong>：SpringMVC + Ibatis + Velocity +   pushlet等    <br><strong>项目描述</strong>：    <br>该交易中心是全国首家权威国资背景的邮币卡电子交易服务平台，项目基于公司新框架JRES2.0上研发，主要由会员中心、交易中心、资金账务和前台门户四大块组成，子系统之间通过Hessian远程接口进行互相调用访问，前台页面运用了Velocity模板引擎将业务逻辑数据与页面设计分离；各子系统按业务功能划分，运用SpringMVC架构实现松散耦合，大量使用接口和泛型重构代码，提高代码可维护性；运用Ibatis实现数据持久化过程，编写动态SQL实现分页排序等功能；利用Axis2框架实现WebService服务供外部系统调用；运用tomcat应用服务器分布部署于多台Linux主机，系统支持PC端WEB应用和手机端APP应用。   交易中心网址：<a href="http://www.shscce.com/" target="_blank" rel="noopener">http://www.shscce.com</a>   <br><strong>主要功能描述</strong>：            <br>1、门户前台：交易中心最新动态，资讯新闻，市场行情信息等。           <br> 2、交易中心：挂牌交易大厅和竞买交易大厅，展示所有卖方上架的商品信息，注册用户可进行购买或竞拍。   <br> 3、后台交易中心：供交易中心工作人员实现鉴定、制作、审核、入库、出库、配送、发货、划款、异议处理、资金结算等整个流程操作的平台。<br>4、会员中心：对交易商、代理商、评审专家、制作人、仓库管理员等等不同角色会员进行管理分配。<br> 5、资金账户中心：支持日终结算，银行对账，第三方支付，资金报表统计等功能。<br><strong>责任描述</strong>：<br>1. 参与前期需求调研，编写需求文档，根据需求绘制流程，编写设计文档，进行数据库设计和代码编写，功能实现。<br>  2.  我隶属于交易组，主要负责交易中心模块的主干功能实现。<br>3.  后期测试阶段bug修复，有时支持下系统发布更新。<br><strong>类似参与项目</strong>：<br>上海石油交易所在线交易系统（担任交易模块负责人）<br><br><br><strong>项目名称</strong>： 浙一医院移动护理系统   <br><strong>周期</strong>：2012年8月至2013年6月   <br><strong>使用技术</strong>：后台EJB3.0 + JPA +   Webservice，前台C# <br> <strong>项目描述</strong>：   <br>1. 该系统以病人为中心，全对象全过程的管理模式，,借助于移动计算和物联网技术,大大降低护理差错率,有效提高医院服务质量,通过有效集成医院相关的各项信息数据,可以实现: 有效的病人身份识别、 消除医嘱执行过程中的各项差错、 保证检验采样过程的正确性、 床边采集各项护理信息、 护理数据共享,消除转抄、 床边待办提醒,提高全体护理人员工作质量。<br> 2. 系统前台面向护理人员提供业务浏览和操作功能，后台管理系统为护理人员提供完备的业务数据统计分析功能。<br>   3. 该系统使用的数据库是oracle，后台部分运用的是EJB3.0+JBOSS开发WebService,EJB3.0对WebService和数据持久化有较好的集成，可通过注解的形式发布WebService供前台调用。数据持久化层运用了JPA框架，因我们经常需要读取医院的HIS库数据，数据源比较分散，所以我们采用配置JNDI树的方式来获取数据源。<br> <strong>主要功能描述</strong>：<br>1.   住院护士站：包括病人住院信息、医嘱信息、体温单、入院评估单、病情护理记录单、护理计划、临床报告、PACE图像、健康教育评价、体征趋势图。   <br>2.              手术护士站：包括手术病人信息、医嘱信息、体温单、病情护理记录单、手术进展、手术物品清单以及手术时间统计等。   <br> 3.              急诊分诊：包括三天内急诊挂号病人信息、急诊病人分诊单、急诊流量统计等。  <br> 4.              急诊护士站：获取已挂号分诊后的病人信息，对其分配床位进行护理管理。   <br>5.              静脉输液：病人置管记录、拔管记录、维护记录、并发症记录、输液反应统计、并发症统计、操作类型统计等。  <br> 6.              门诊护理：读取医保卡或市民卡，录入门诊病人初诊、复诊评估单。   <br>7.              归档病人查询、系统管理：已归档病人查询、字典配置、各评估模板和参数配置。   <br><strong>责任描述</strong>：   <br>1.              参与浙一移动护理系统项目组核心业务开发，负责后台功能业务。   <br>2.              根据现场需求进行流程分析与编写及参与概要设计的讨论，以便于增加在开发中对业务熟悉度。  <br> 3.              根据所需求的业务进行开发，代码编写，实现功能。   <br>4.              对程序业务逻辑和服务器进行优化，使其达到更高的性能。  <br> 5.              提供使用说明，及后期中维护的方案给于实施工程师。       <br><strong>类似参与项目</strong>：       <br>浙江大学医学院附属第二医院护理系统         <br>  宁波北仑人民医院护理系统          <br> 宁波象山第一人民医院护理系统</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;title: 履历&lt;br&gt;keywords: ‘读书’&lt;br&gt;date: 2017-10-14 11:25:06&lt;br&gt;password: 26592001&lt;br&gt;categories: 读书&lt;br&gt;tags: 读书&lt;/p&gt;
&lt;p&gt;description:&lt;/p&gt;
&lt;blockquote class=&quot;blockquote-center&quot;&gt;有人的地方就是江湖&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定时任务调度设计与实现</title>
    <link href="http://jasoncui.com/2018/02/17/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jasoncui.com/2018/02/17/定时任务调度设计与实现/</id>
    <published>2018-02-17T13:03:04.000Z</published>
    <updated>2018-06-14T10:03:34.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="description"><a href="#description" class="headerlink" title="description:"></a>description:</h2><blockquote class="blockquote-center"><br>很多时候业务系统中有定时任务或者定时超时处理的需求，当任务量很大时，需要维护大量的timer，或者进行低效的扫描，本文针对此类业务场景与大家分享一种高效实时的解决方式。<br></blockquote><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>很多时候，业务中有“在一段时间之后，完成一个工作任务”的需求。</p><p>例如：客户下单待支付，如果超过30分钟未支付，系统自动关闭该订单。</p><p>入职以来碰到多次CPU100%，数据库查询超时异常等情况，疑似定时任务扫库引起。</p><h3 id="常见方案："><a href="#常见方案：" class="headerlink" title="常见方案："></a>常见方案：</h3><p>​    1，“轮询扫描法”：启动一个cron定时任务，定期跑一次，将未支付的到期订单关闭，如果数据量很大，需要分页查询，分页update，这将会是一个for循环。</p><p>​    2，“多timer触发法”：针对每个任务启动一个timer，30分钟后触发是否需要关闭。</p><h5 id="方案1不足："><a href="#方案1不足：" class="headerlink" title="方案1不足："></a>方案1不足：</h5><p>​    1，轮询效率比较低</p><p>​    2，每次扫库，已经被执行过的记录，仍然会被扫描（只是不会出现在结果集中），有重复计算的嫌疑</p><p>​    3，时效性不够好，如果每小时轮询一次，最差的情况下，时间误差会达到1小时。</p><p>​    4，如果通过增加cron轮询频率来减少上面的时间误差，那轮询效率和重复计算的问题会进一步凸显。</p><h5 id="方案2不足："><a href="#方案2不足：" class="headerlink" title="方案2不足："></a>方案2不足：</h5><p>​    每个任务启动一个timer，比较耗资源，特别是在线量很大时，很容易CPU100%。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="环形队列-时间轮"><a href="#环形队列-时间轮" class="headerlink" title="环形队列+时间轮"></a>环形队列+时间轮</h4><p><img src="http://ojb6w1er1.bkt.clouddn.com/2018-06-14-062000.jpg" alt="img"></p><p>​    先对本图做个简单的解释，图中包含一个环形队列和多个任务集合，环形队列中每个slot对应一个时间单位，可以是小时、分钟、秒等，每个slot下挂着一个Set<task>，用于存储待处理任务。当timer启动后，假设每隔1秒在环形队列中移动一格，当currentIndex指向一个slot时，可以检测该slot下有无待处理任务。在Set中的Task具备两个重要属性：cycleNum（当currentIndex第几圈扫描到这个slot时执行任务），taskFunction（需要执行的任务指针）。</task></p><p>​    所以当需要触发一个延时任务时，我们只需做到两点：1，计算这个Task应该放在哪一个slot；2，计算这个Task的cycleNum，假设环形队列设置为3600格，currentIndex每秒移动一格，那任务希望3610秒后执行，则3610/3600=1，cycleNum=1，该task放入第10个slot中。</p><h4 id="方案优点"><a href="#方案优点" class="headerlink" title="方案优点"></a>方案优点</h4><p>​    1，无需再轮询全部业务订单，效率高。</p><p>​    2，一个订单，任务只执行一次。</p><p>​    3，时效性好，精确到秒（控制timer移动频率可以控制精度）。</p><h2 id="方案解析"><a href="#方案解析" class="headerlink" title="方案解析"></a>方案解析</h2><p><img src="http://ojb6w1er1.bkt.clouddn.com/2018-06-14-073316.png" alt="b352d7733bcc234ea2f968840d1eeac67a34fb81"></p><p>​    上图的方案优点在于将任务的存储和时间进行解耦，而以什么方式存储任务数据则是该方案的关键。在RocketMQ（商业版）中的实现是将任务数据以链表的方式写入磁盘，每个任务中都有一个指向下一个任务的磁盘offset，只要拿到链表的头就可以获取整个任务链表，但该方案的缺点是部署时需要依赖硬盘，在当前容器化以及容量动态扩容的趋势下，一个普通应用依赖一块固定磁盘，对运维和部署带来额外复杂度。</p><h4 id="优化设计"><a href="#优化设计" class="headerlink" title="优化设计"></a>优化设计</h4><p>​    基于上述问题，存储方式可以改为以Hbase，Redis来存储结构化数据，将上述磁盘offset换成任务ID，时间轮上关联链表头的ID，从而解耦对磁盘的依赖。于是方案变成下图：</p><p><img src="http://ojb6w1er1.bkt.clouddn.com/2018-06-14-085742.png" alt="img"></p><p>​    该方案至此在数据量不是很大的应用中已经够用，但在大量数据下时依然存在以下问题：</p><p>​    1，单一链表无法并行提取，从而影响提取效率，对于某个时刻有大量定时任务的时候，定时任务处理的延迟会比较严重。</p><p>​    2，在调度集群服务中各个节点拥有自己的时间轮，那么在集群里面每个节点重启之后如何恢复？集群扩容&amp;缩容如何自动管理？</p><h4 id="任务链表分区–加速单一链表提取"><a href="#任务链表分区–加速单一链表提取" class="headerlink" title="任务链表分区–加速单一链表提取"></a>任务链表分区–加速单一链表提取</h4><p>​    链表的好处是在内存中不用存储整个任务列表，只需要存储简单的ID，这样减少了内存的消耗，但单一链表提取效率有限，这里利用分区原理，将某个时刻的单一链表通过分区的方式拆分成多个链表，当将某个时间点的任务提取的时候，可以根据链表集合大小来并行处理，从而加速整个任务提取的速度。所以方案演变成下图</p><p><img src="http://ojb6w1er1.bkt.clouddn.com/2018-06-14-092642.png" alt="img"></p><h4 id="集群管理—集群节点的自我识别"><a href="#集群管理—集群节点的自我识别" class="headerlink" title="集群管理—集群节点的自我识别"></a>集群管理—集群节点的自我识别</h4><p>​    在集群部署后节点重启后如何进行恢复？比如需要知道重启之前的时间轮刻度，需要知道重启之间时间轮刻度上的定时任务链表数据等，这里统一称之为时间轮元数据。由于各节点都是无状态的，所以各节点启动的时候，并不知道如何从存储服务中读取属于自己的元数据，这里就需要给集群中每个节点分配一个逻辑ID（因为动态扩容缩容问题，无法给每个节点分配固定IP或mac地址，奢侈），每个节点可以根据逻辑ID去存储服务获取对应的元数据。</p><p>​    自此引出一个问题，逻辑ID如何分配？那么集群中节点就要选举一个Master节点，由Master来统一分配逻辑ID，集群启动注册和分配ID过程如下图<img src="http://ojb6w1er1.bkt.clouddn.com/2018-06-14-093959.png" alt="img"></p><p>​    在解决了集群节点获取元数据问题之后，可能会出现另一个问题，那就是某个时刻某个节点的到期任务量较大，从而导致集群中该节点的压力很大，为了能够合理利用集群计算能力，该方案可以进一步优化：将提取的到期任务链表集合通过软负载的方式分发给集群其他节点，同时由于任务的数据是集中存储的，只要其他节点能够拿到任务链表头的ID，便可以提取到该链表的所有任务，从而集群的压力也将被平摊。以下是该方案交互过程：<img src="http://ojb6w1er1.bkt.clouddn.com/2018-06-14-093934.png" alt="27e57afae8c16a21242aa5d82e710be784a9100c"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    在对该方案的解析过程中，我们发现该调度系统需要解决以下几个难点：</p><p>​    1，时间轮算法实现</p><p>​    2，任务链表和任务数据存储、任务链表分区、提取、删除。</p><p>​    3，调度节点注册发现、Master选举策略</p><p>​    4，调度节点的逻辑ID分配，元数据恢复</p><p>​    5，到期任务链表集群软负载</p><blockquote><p>外部链接：<a href="http://www.10tiao.com/html/249/201703/2651959961/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/249/201703/2651959961/1.html</a></p><p>外部链接：<a href="https://yq.aliyun.com/articles/581147" target="_blank" rel="noopener">https://yq.aliyun.com/articles/581147</a></p><p>外部链接：<a href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/" target="_blank" rel="noopener">https://zacard.net/2016/12/02/netty-hashedwheeltimer/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;description&quot;&gt;&lt;a href=&quot;#description&quot; class=&quot;headerlink&quot; title=&quot;description:&quot;&gt;&lt;/a&gt;description:&lt;/h2&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;很多时候业务系统中有定时任务或者定时超时处理的需求，当任务量很大时，需要维护大量的timer，或者进行低效的扫描，本文针对此类业务场景与大家分享一种高效实时的解决方式。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://jasoncui.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jasoncui.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>爬虫抓取代理IP</title>
    <link href="http://jasoncui.com/2018/01/17/%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E4%BB%A3%E7%90%86IP/"/>
    <id>http://jasoncui.com/2018/01/17/爬虫抓取代理IP/</id>
    <published>2018-01-17T13:03:04.000Z</published>
    <updated>2018-03-10T07:59:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>由于某些网站对会对爬虫做限制，因此常常需要通过代理将爬虫的实际IP隐蔽起来，代理也有分类，如透明代理，高匿代理等。本文主要讲述如何获取代理IP，并且如何存储和使用。<br></blockquote><a id="more"></a><p> 某些网站会免费提供代理IP，如下面的几个<br>获取这些页面上的代理IP及端口也是通过爬虫抓取，下面以第一个网站<a href="http://www.xicidaili.com为例，解释如何获取并存储这些代理IP。一般的流程为：解析当前页面--&gt;存储当前页面的代理IP--&gt;跳转到下一页面，重复该流程即可。" target="_blank" rel="noopener">http://www.xicidaili.com为例，解释如何获取并存储这些代理IP。一般的流程为：解析当前页面--&gt;存储当前页面的代理IP--&gt;跳转到下一页面，重复该流程即可。</a></p><p>##解析页面<br>首先要解析页面，由于网页中显示代理IP时是在表格中显示的，因此只需要通过找出网页源码中相关的表格元素即可。下面是通过python中的requests和bs4获取页面<a href="http://www.xicidaili.com/nt/上显示的IP及端口。" target="_blank" rel="noopener">http://www.xicidaili.com/nt/上显示的IP及端口。</a><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">user_agent = &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36&apos;</span><br><span class="line">referer = &apos;http://www.xicidaili.com/&apos;</span><br><span class="line">headers = &#123;&apos;user-agent&apos;: user_agent, &apos;referer&apos;: referer&#125;</span><br><span class="line">target = &apos;http://www.xicidaili.com/nt/&apos;</span><br><span class="line"></span><br><span class="line">//获取页面源码</span><br><span class="line">r = requests.get(target, headers = headers)</span><br><span class="line">//解析页面源码</span><br><span class="line">soup = BeautifulSoup(r.text, &apos;lxml&apos;)</span><br><span class="line">for tr in soup.find_all(&apos;tr&apos;)[1:]:</span><br><span class="line">tds = tr.find_all(&apos;td&apos;)</span><br><span class="line">proxy = tds[1].text+&apos;:&apos;+tds[2].text</span><br><span class="line">print proxy</span><br></pre></td></tr></table></figure></p><p>输出如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  36.235.1.189:3128</span><br><span class="line">219.141.225.149:80</span><br><span class="line">125.44.132.44:9999</span><br><span class="line">123.249.8.100:3128</span><br><span class="line">183.54.30.186:9999</span><br><span class="line">110.211.45.228:9000</span><br><span class="line">...........</span><br></pre></td></tr></table></figure><p>###代理IP的存储<br>上面代码获取的代理IP可以通过在代码一开始建立一个集合（set）来存储，这种情况适用于一次性使用这些代理IP，当程序发生异常或正常退出后，这些存储在内存中的代理IP也会丢失。但是爬虫中使用代理IP的情况又是非常多的，所以有必要把这些IP存储起来，从而可以让程序多次利用。<br>这里主要通过redis数据库存储这些代理IP，redis是一个NOSQL数据库，具体使用参照官方文档，这里不做详细解释。<br>下面是ConnectRedis.py文件，用于连接redis<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line">HOST = &apos;XXX.XXX.XXX.XXX&apos; # redis所在主机IP</span><br><span class="line">PORT = 6379 # redis服务监听的端口</span><br><span class="line">PASSWORD = &apos;XXXXXX&apos; # 连接redis的密码</span><br><span class="line">DB = 0 # IP存储的DB编号</span><br><span class="line"></span><br><span class="line">def get_connection():</span><br><span class="line">r = redis.Redis(host = HOST, port = PORT, password = PASSWORD, db= DB)</span><br><span class="line">return r</span><br></pre></td></tr></table></figure></p><p>下面是在上面的代码基础上将IP存储到redis中，</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">from ConnectRedis import get_connection</span><br><span class="line">//获取redis连接</span><br><span class="line">try:</span><br><span class="line">conn = get_connection()</span><br><span class="line">except Exception:</span><br><span class="line">print &apos;Error while connecting to redis&apos;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">user_agent = &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36&apos;</span><br><span class="line">referer = &apos;http://www.xicidaili.com/&apos;</span><br><span class="line">headers = &#123;&apos;user-agent&apos;: user_agent, &apos;referer&apos;: referer&#125;</span><br><span class="line">target = &apos;http://www.xicidaili.com/nt/&apos;</span><br><span class="line"></span><br><span class="line">//获取页面源码</span><br><span class="line">r = requests.get(target, headers = headers)</span><br><span class="line">//解析页面源码</span><br><span class="line">soup = BeautifulSoup(r.text, &apos;lxml&apos;)</span><br><span class="line">for tr in soup.find_all(&apos;tr&apos;)[1:]:</span><br><span class="line">tds = tr.find_all(&apos;td&apos;)</span><br><span class="line">proxy = tds[1].text+&apos;:&apos;+tds[2].text</span><br><span class="line">conn.sadd(&quot;ip_set&quot;, proxy)</span><br><span class="line">print &apos;%s added to ip set&apos;%proxy</span><br></pre></td></tr></table></figure><p>上面的conn.sadd(“ip_set”, proxy)将代理proxy加入到redis的集合”ip_set”，这个集合需要预先在redis中创建，否则会出错。</p><p>###页面跳转<br>上面的代码获取的只是一个页面上显示的代理，显然这个数量不够，一般通过当前页面中的下一页的超链接可以跳转到下一页，但是我们测试的由于每页的的url都有规律，都是<a href="http://www.xicidaili.com/nt/page_number,其中的page_number表示当前在哪一页，省略时为第一页。因此，通过一个for循环嵌套上面的代码即可获取多个页面的代理。但是更一般的方法是通过在当前页面获取下一页的超链接而跳转到下一页。" target="_blank" rel="noopener">http://www.xicidaili.com/nt/page_number,其中的page_number表示当前在哪一页，省略时为第一页。因此，通过一个for循环嵌套上面的代码即可获取多个页面的代理。但是更一般的方法是通过在当前页面获取下一页的超链接而跳转到下一页。</a></p><p>###代理IP的使用<br>当我们需要通过代理访问某一网站时，首先需要从redis中随机选出一个代理ip，然后尝试通过代理ip是否能连到我们需要访问的目标网站，因为这些代理IP是公共使用的，所以往往也会被封的很快，假如通过代理无法访问目标网站，那么就要从数据库中删除这个代理IP。反之即可通过此代理访问目标网站<br>下面是实现上面所说流程的代码：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from ConnectRedis import get_connection</span><br><span class="line"></span><br><span class="line">//判断IP是否能访问目标网站</span><br><span class="line">def is_valid(url, ip):</span><br><span class="line">proxy = &#123;</span><br><span class="line">&apos;http&apos;: &apos;http://%s&apos; %ip</span><br><span class="line">&#125;</span><br><span class="line">user_agent = &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36&apos;</span><br><span class="line">headers = &#123;&apos;user-agent&apos;: user_agent&#125;</span><br><span class="line">try:</span><br><span class="line">r = requests.get(url, headers = headers, proxies = proxy, timeout = 6)</span><br><span class="line">return True</span><br><span class="line">except Exception:</span><br><span class="line">return False</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">my_proxy, proxies, ip_set = None, None, &apos;amazon_ips&apos;</span><br><span class="line">conn = get_connection()</span><br><span class="line">target = &apos;https://www.amazon.com/&apos;</span><br><span class="line">while not is_valid(target, my_proxy):</span><br><span class="line">if my_proxy:</span><br><span class="line">conn.srem(ip_set, my_proxy) #删除无效的代理IP</span><br><span class="line">if proxies:</span><br><span class="line">my_proxy = proxies.pop()</span><br><span class="line">else:</span><br><span class="line">proxies = conn.srandmember(ip_set, 5) #从redis中随机抽5个代理ip</span><br><span class="line">my_proxy = proxies.pop()</span><br><span class="line">print &apos;valid proxy %s&apos; %my_proxy</span><br></pre></td></tr></table></figure></p><p>requests.get(url, headers = headers, proxies = proxy, timeout = 6)是通过代理去访问目标网站，超时时间设为6s，也就是说在6秒内网站没有回应或返回错误信息就认为这个代理无效。<br>除此之外，在爬取免费提供代理的网站上的代理IP的时候，爬取的速度不要太快，其中的一个原因是爬取太快有可能会被封，另外一个原因是如果每个人都无间隙地从这种网站上爬取，那么网站的负担会比较大，甚至有可能垮掉，因此采用一个可持续爬取的策略非常有必要，我爬取的时候是没爬完一个页面后让程序sleep大概2分钟，这样下来不会被封而且爬取的代理的量也足够使用。实际中可以根据自己使用代理的频率来进行调整。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;由于某些网站对会对爬虫做限制，因此常常需要通过代理将爬虫的实际IP隐蔽起来，代理也有分类，如透明代理，高匿代理等。本文主要讲述如何获取代理IP，并且如何存储和使用。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://jasoncui.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://jasoncui.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用指令</title>
    <link href="http://jasoncui.com/2017/12/12/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://jasoncui.com/2017/12/12/Docker常用指令/</id>
    <published>2017-12-12T02:02:44.000Z</published>
    <updated>2018-03-10T07:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>Docker常用指令<br></blockquote><a id="more"></a><h3 id="容器清理"><a href="#容器清理" class="headerlink" title="容器清理"></a>容器清理</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>|xargs docker stop</span><br><span class="line"></span><br><span class="line">docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>|xargs docker rm</span><br><span class="line"></span><br><span class="line">docker images|grep none|awk <span class="string">'&#123;print $3 &#125;'</span>|xargs docker rmi</span><br></pre></td></tr></table></figure><h3 id="查看虚悬镜像"><a href="#查看虚悬镜像" class="headerlink" title="查看虚悬镜像"></a>查看虚悬镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f dangling=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="删除虚悬镜像"><a href="#删除虚悬镜像" class="headerlink" title="删除虚悬镜像"></a>删除虚悬镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling=<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><h3 id="查看在mongo-3-2之后建立的镜像"><a href="#查看在mongo-3-2之后建立的镜像" class="headerlink" title="查看在mongo:3.2之后建立的镜像"></a>查看在mongo:3.2之后建立的镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f since=mongo:<span class="number">3.2</span></span><br></pre></td></tr></table></figure><h3 id="查看在mongo-3-2之前建立的镜像"><a href="#查看在mongo-3-2之前建立的镜像" class="headerlink" title="查看在mongo:3.2之前建立的镜像"></a>查看在mongo:3.2之前建立的镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -f before=mongo:<span class="number">3.2</span></span><br></pre></td></tr></table></figure><h3 id="在容器基础上构建新镜像"><a href="#在容器基础上构建新镜像" class="headerlink" title="在容器基础上构建新镜像"></a>在容器基础上构建新镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br><span class="line"></span><br><span class="line">docker commit \</span><br><span class="line">--author <span class="string">"Tao Wang &lt;twang2218@gmail.com&gt;"</span> \</span><br><span class="line">--message <span class="string">"修改了默认网页"</span> \</span><br><span class="line">webserver \</span><br><span class="line">nginx:v2</span><br><span class="line">sha256:<span class="number">07e33465974800</span>ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p <span class="number">81</span>:<span class="number">80</span> nginx:v2</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [选项] &lt;镜像<span class="number">1</span>&gt; [&lt;镜像<span class="number">2</span>&gt; ...]</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm</span><br></pre></td></tr></table></figure><h3 id="清除所有终止状态的容器"><a href="#清除所有终止状态的容器" class="headerlink" title="清除所有终止状态的容器"></a>清除所有终止状态的容器</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure><h3 id="创建数据卷容器"><a href="#创建数据卷容器" class="headerlink" title="创建数据卷容器"></a>创建数据卷容器</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -v /dbdata --name dbdata training/postgres</span><br><span class="line">echo Data-only container <span class="keyword">for</span> postgres</span><br></pre></td></tr></table></figure><h3 id="挂载数据卷容器中的数据卷"><a href="#挂载数据卷容器中的数据卷" class="headerlink" title="挂载数据卷容器中的数据卷"></a>挂载数据卷容器中的数据卷</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --volumes-from dbdata --name db1 training/p</span><br><span class="line">ostgres</span><br><span class="line">$ sudo docker run -d --volumes-from dbdata --name db2 training/p</span><br><span class="line">ostgres</span><br></pre></td></tr></table></figure><h3 id="build-构建镜像"><a href="#build-构建镜像" class="headerlink" title="build: 构建镜像"></a>build: 构建镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t oauth2-server:<span class="number">0.6</span>.0 .</span><br></pre></td></tr></table></figure><h3 id="run-运行镜像"><a href="#run-运行镜像" class="headerlink" title="run: 运行镜像"></a>run: 运行镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//守护进程形式 </span></span><br><span class="line">   docker run -d -p <span class="number">8180</span>:<span class="number">8180</span> --name oa oauth2-server:<span class="number">0.6</span>.0</span><br><span class="line"><span class="comment">//shell交互形式(本服务不支持，可运行其他镜像) </span></span><br><span class="line">   docker run -i -t --rm java:<span class="number">8</span> /bin/bash</span><br></pre></td></tr></table></figure><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f --tail=<span class="number">100</span> ContainerId</span><br><span class="line">* -f, --follow=<span class="keyword">false</span> 跟踪日志输出。 </span><br><span class="line">* -t, --timestamps=<span class="keyword">false</span> 显示时间戳。 </span><br><span class="line">* --tail=<span class="string">"all"</span> 输出日志尾部特定行(默认是所有)。 </span><br><span class="line">* --since=<span class="string">""</span> 时间段</span><br></pre></td></tr></table></figure><h3 id="查看磁盘挂载"><a href="#查看磁盘挂载" class="headerlink" title="查看磁盘挂载"></a>查看磁盘挂载</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;.Volumes&#125;&#125; ContainerId</span><br></pre></td></tr></table></figure><h3 id="导出日志目录"><a href="#导出日志目录" class="headerlink" title="导出日志目录"></a>导出日志目录</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ContainerId:/var/log/oauth2-server /local/path</span><br></pre></td></tr></table></figure><h3 id="谨慎操作"><a href="#谨慎操作" class="headerlink" title="谨慎操作"></a>谨慎操作</h3><ul><li><p>删除一个镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f ImageId</span><br></pre></td></tr></table></figure></li><li><p>删除所有镜像 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure></li><li><p>删除一个容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v -f ContainerId</span><br></pre></td></tr></table></figure></li><li><p>删除所有容器 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure></li><li><p>删除旧的容器 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep <span class="string">'weeks ago'</span> | awk <span class="string">'&#123;print $1&#125;'</span> | xargs docker rm -v -f</span><br></pre></td></tr></table></figure></li><li><p>删除停止状态的容器 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v -f $(docker ps -a -q -f status=exited)</span><br></pre></td></tr></table></figure></li><li><p>设置容器的磁盘空间（需要重启docker）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　docker -d --storage-opt dm.basesize=<span class="number">50</span>G</span><br></pre></td></tr></table></figure></li><li><p>在容器中执行命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　docker exec -i -t ContainerName myshell </span><br><span class="line">* -d, --detach=<span class="keyword">false</span> Detached mode: run command in the background</span><br><span class="line">* -i, --interactive=<span class="keyword">false</span> Keep STDIN open even <span class="keyword">if</span> not attached</span><br><span class="line">* -t, --tty=<span class="keyword">false</span> Allocate a pseudo-TTY</span><br><span class="line">* -u, --user= <span class="function">Username or <span class="title">UID</span> <span class="params">(format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span></span></span><br><span class="line"><span class="function">如: docker exec -i -t ContainerName /bin/bash</span></span><br></pre></td></tr></table></figure></li><li><p>提交容器当前状态到镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">* -a, --author=<span class="string">""</span> Author (e.g., <span class="string">"John Hannibal Smith &lt;hannibal@a-team.com&gt;"</span>)</span><br><span class="line">* -c, --change=[] Apply specified Dockerfile instructions <span class="keyword">while</span> committing the image</span><br><span class="line">* -m, --message=<span class="string">""</span> Commit message</span><br><span class="line">* -p, --pause=<span class="keyword">true</span> Pause container during commit</span><br></pre></td></tr></table></figure></li><li><p>保存/备份镜像到本地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* docker save -o /local/path/fedora-latest.tar fedora:latest</span><br><span class="line">* docker save fedora:latest &gt; /local/path/fedora-latest.tar</span><br></pre></td></tr></table></figure></li><li><p>加载本地镜像文件到docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* docker load --input fedora.tar</span><br><span class="line">* docker load &lt; fedora.tar</span><br></pre></td></tr></table></figure></li><li><p>容器与主机文件/目录传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* docker cp [options] CONTAINER:PATH LOCALPATH</span><br><span class="line">* docker cp [options] LOCALPATH CONTAINER:PATH</span><br></pre></td></tr></table></figure></li><li><p>连接到运行的容器中（谨慎使用，不推荐）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   * docker attach [OPTIONS] CONTAINERID</span><br><span class="line">* --no-stdin=<span class="keyword">false</span> Do not attach STDIN</span><br><span class="line">* --sig-proxy=<span class="keyword">true</span> Proxy all received signals to the process</span><br></pre></td></tr></table></figure></li><li><p>退出attach</p></li><li>默认情况下，如果使用ctrl-c退出container,那么container也会stop</li><li>按ctrl-p ctrl-q可以退出到宿主机，而保持container仍然在运行</li><li><p>查看容器或镜像的详细信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class="line"></span><br><span class="line">* -f, --format=<span class="string">""</span> Format the output using the given go template</span><br><span class="line">* --type=container|image Return JSON <span class="keyword">for</span> specified type, permissible values are <span class="string">"image"</span> or <span class="string">"container"</span></span><br></pre></td></tr></table></figure><ul><li>docker run 可选参数<ul><li>-c/–cpu-shares 512 每个CPU的配额（1024允许占用全部CPU）</li><li>–cpuset=0,1 只允许运行在前两个CPU上（–cpu 2）</li><li>–cpu 4 使用四核（加载run命令的末尾）</li><li>-m 128m 内存分配 详细参考Docker容器资源管理</li><li>–dns 覆盖容器默认dns配置</li><li>–mac-address 覆盖容器默认mac地址配置</li><li>–add-host 添加hosts（如–add-host db-static:86.75.30.9）</li><li>–security-opt 指定安全策略（主机配置）</li><li>–privileged Docker将拥有访问主机所有设备的权限</li><li>–device 指定容器可访问的设备（如–device=/dev/snd:/dev/snd:rwx rwx为权限）</li><li>–rm 容器停止后删除容器(不与-d一起使用) </li><li>-e 设置环境变量（如-e “deep=purple”）</li><li>-h 来设定hostname</li><li>–link name:alias 连接其他容器</li><li>-v $HOSTDIR:$DOCKERDIR 挂载主机目录到容器目录</li><li>–read-only 设置容器只读</li></ul></li><li><p>docker run –net 参数</p><ul><li>none。关闭容器内的网络连接 将网络模式设置为none时，这个容器将不允许访问任何外部router。 这个容器内部只会有一个loopback接口，而且不存在任何可以访问外部网络的router。</li><li>bridge。通过veth接口来连接容器，默认配置。 Docker默认会将容器设置为bridge模式。此时在主机上面将会存在一个docker0的网络接口， 同时会针对容器创建一对veth接口。其中一个veth接口是在主机充当网卡桥接作用，另外一个veth接口存在于容器的命名空间中， 并且指向容器的loopback。Docker会自动给这个容器分配一个IP，并且将容器内的数据通过桥接转发到外部。</li><li>host。允许容器使用host的网络堆栈信息。 注意：这种方式将允许容器访问host中类似D-BUS之类的系统服务，所以认为是不安全的。 当网络模式设置为host时，这个容器将完全共享host的网络堆栈。host所有的网络接口将完全对容器开放。 容器的主机名也会存在于主机的hostname中。这时，容器所有对外暴露的端口和对其它容器的连接，将完全失效。</li><li>container。使用另外一个容器的网络堆栈信息。 当网络模式设置为Container时，这个容器将完全复用另外一个容器的网络堆栈。 同时使用时这个容器的名称必须要符合下面的格式：–net container:&lt;name|id&gt;.</li></ul></li><li><p>查看镜像历史</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   docker history [OPTIONS] IMAGE</span><br><span class="line">-H, --human=<span class="keyword">true</span> Print sizes and dates in human readable format</span><br><span class="line">--no-trunc=<span class="keyword">false</span> Don<span class="string">'t truncate output</span></span><br><span class="line"><span class="string">-q, --quiet=false Only show numeric IDs</span></span><br></pre></td></tr></table></figure></li><li><p>导出镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   docker export [OPTIONS] CONTAINER</span><br><span class="line">docker export exampleimage &gt; exampleimage.tar</span><br><span class="line">docker export --output=<span class="string">"exampleimage.tar"</span> exampleimage</span><br></pre></td></tr></table></figure></li><li><p>导入镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   docker <span class="keyword">import</span> URL|- [REPOSITORY[:TAG]]</span><br><span class="line">docker <span class="keyword">import</span> http:<span class="comment">//example.com/exampleimage.tgz</span></span><br><span class="line">cat exampleimage.tgz | docker <span class="keyword">import</span> - exampleimagelocal:<span class="keyword">new</span></span><br></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br><span class="line">docker stop container --stops it.</span><br><span class="line">docker start container --will start it again.</span><br><span class="line">docker restart container --restarts a container.</span><br><span class="line">docker kill container --sends a SIGKILL to a container.</span><br><span class="line">docker wait container --blocks until container stops.</span><br><span class="line">docker port container --shows <span class="keyword">public</span> facing port of container.</span><br><span class="line">docker top container --shows running processes in container.</span><br><span class="line">docker stats container --shows containers<span class="string">' resource usage statistics.</span></span><br><span class="line"><span class="string">docker diff container --shows changed files in the container'</span>s FS.</span><br><span class="line">docker events --gets events from container.</span><br><span class="line">docker login --to login to a registry.</span><br><span class="line">docker search --searches registry <span class="keyword">for</span> image.</span><br><span class="line">docker pull pulls an image from registry to local machine.</span><br><span class="line">docker push --pushes an image to the registry from local machine.</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="本地生成镜像，打包发布"><a href="#本地生成镜像，打包发布" class="headerlink" title="本地生成镜像，打包发布"></a>本地生成镜像，打包发布</h3><h4 id="本地项目根目录下创建Dockerfile"><a href="#本地项目根目录下创建Dockerfile" class="headerlink" title="本地项目根目录下创建Dockerfile"></a>本地项目根目录下创建Dockerfile</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM java:openjdk-<span class="number">8</span>-jre</span><br><span class="line">WORKDIR /usr/src/</span><br><span class="line">COPY target/academic-<span class="number">0.0</span>.1.jar /usr/src/</span><br><span class="line">CMD [<span class="string">"java"</span>, <span class="string">"-Duser.timezone=GMT+08"</span>, <span class="string">"-jar"</span>, <span class="string">"academic-0.0.1.jar"</span>]</span><br><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">EXPOSE <span class="number">8072</span></span><br></pre></td></tr></table></figure><h4 id="在Dockerfile所在目录执行创建镜像指令"><a href="#在Dockerfile所在目录执行创建镜像指令" class="headerlink" title="在Dockerfile所在目录执行创建镜像指令"></a>在Dockerfile所在目录执行创建镜像指令</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t academic .  (-t academic是为镜像指定名称为academic)</span><br></pre></td></tr></table></figure><h4 id="打包镜像为tar文件"><a href="#打包镜像为tar文件" class="headerlink" title="打包镜像为tar文件"></a>打包镜像为tar文件</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save academic &gt; academic.tar</span><br></pre></td></tr></table></figure><h4 id="上传academic-tar至服务器"><a href="#上传academic-tar至服务器" class="headerlink" title="上传academic.tar至服务器"></a>上传academic.tar至服务器</h4><h4 id="ssh到服务器，执行导出镜像命令"><a href="#ssh到服务器，执行导出镜像命令" class="headerlink" title="ssh到服务器，执行导出镜像命令"></a>ssh到服务器，执行导出镜像命令</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; academic.tar</span><br></pre></td></tr></table></figure><h4 id="编写docker-compose-yml文件"><a href="#编写docker-compose-yml文件" class="headerlink" title="编写docker-compose.yml文件"></a>编写docker-compose.yml文件</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行dc up -d 即可</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;Docker常用指令&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://jasoncui.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jasoncui.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker加速器配置</title>
    <link href="http://jasoncui.com/2017/12/07/Docker%E5%8A%A0%E9%80%9F%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://jasoncui.com/2017/12/07/Docker加速器配置/</id>
    <published>2017-12-07T13:03:04.000Z</published>
    <updated>2018-03-10T07:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用了Docker的都知道在使用docker pull来拉取镜像时的速度都非常慢，而且还会经常报错（如：超时、镜像不存在等错误）。<br>主要原因大家都知道：Registry在国内，网络影响太严重。还好国内的一些大企业对此做了些解决办法：加速器，比较常用的有阿里云和DaoCloud。要使用加速器都需要先注册一个对应的账号，我这里已经在这两个网站上都注册过了。<br><br></blockquote><a id="more"></a><h2 id="Centos7中配置Docker加速器"><a href="#Centos7中配置Docker加速器" class="headerlink" title="Centos7中配置Docker加速器"></a>Centos7中配置Docker加速器</h2><ul><li>DaoCloud加速器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://XXX.m.daocloud.io</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：XXX是自己的地址，注册账号后可以得到这个地址，可以参考官方文档：<a href="https://link.jianshu.com/?t=https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">《配置 Docker 加速器》</a>，上面这条命令适用于Ubuntu14.04、Debian、CentOS6 、CentOS7，并且可以帮助您配置registry-mirror加速地址并重启Docker Daemon。</p></blockquote><ul><li><p>阿里云加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  sudo cp -n /lib/systemd/system/docker.service /etc/systemd/system/docker.service</span><br><span class="line">sudo sed -i &quot;s|ExecStart=/usr/bin/docker daemon|ExecStart=/usr/bin/docker daemon --registry-mirror=https://XXX.mirror.aliyuncs.com|g&quot; /etc/systemd/system/docker.service</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><blockquote><p>注意：XXX也是注册阿里云账号后的一个地址，可以参考官方文档：<a href="https://link.jianshu.com/?t=https://cr.console.aliyun.com/?spm=5176.2020520152.209.d103.Wa88wv#/accelerator" target="_blank" rel="noopener">《配置Docker加速器》</a></p></blockquote><p><strong>需要特别注意的是：阿里云在Linux系统中的加速器只支持Docker 1.9版本以上，Centos7以上，Ubuntu 12以上，个人感觉阿里云在Linux系统中的支持不如DaoCloud的完美。</strong></p><h2 id="Windows中配置Docker加速器"><a href="#Windows中配置Docker加速器" class="headerlink" title="Windows中配置Docker加速器"></a>Windows中配置Docker加速器</h2></li><li><p>DaoCloud加速器<br><em>为已存在的docker-machine配置加速器（假设machine名称为tmp-machine）</em></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh tmp-machine</span><br><span class="line">cd /var/lib/boot2docker</span><br><span class="line">vi profile</span><br></pre></td></tr></table></figure></li></ul><p><em>在EXTRA_ARGS中配置加速地址，即修改为：</em><br>  <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTRA_ARGS=<span class="string">'</span></span><br><span class="line"><span class="string">--label provider=virtualbox</span></span><br><span class="line"><span class="string">--registry-mirror http://XXX.m.daocloud.io'</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意：XXX需要更换成自己的加速地址（–registry-mirror后面是空格不是等号），保存并退出，然后输入命令：docker-machine restart tmp-machine重启虚拟主机。</p></blockquote><p><em>docker-machine create时配置加速器</em><br>  <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d virtualbox --engine-registry-mirror=http://XXX.m.daocloud.io tmp-machine</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：XXX需要更换成自己的加速地址，这样创建了一个名为tmp-machine的docker虚拟机，并设置了相应的加速器。</p></blockquote><ul><li>阿里云加速器</li></ul><p>Windows中使用阿里云的加速器配置方法与配置DaoCloud加速器的方法是一样的，需要注意的是阿里云的加速器地址是以https://开头，格式如：<a href="https://XXX.mirror.aliyuncs.com，将上面所说的加速器地址更新成阿里云的就可以了。" target="_blank" rel="noopener">https://XXX.mirror.aliyuncs.com，将上面所说的加速器地址更新成阿里云的就可以了。</a><br>个人用了加速器后的体会是：在Linux系统中DaoCloud的加速器比阿里云的要好用，在Windows系统中阿里云的加速器比DaoCloud的速度快。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用了Docker的都知道在使用docker pull来拉取镜像时的速度都非常慢，而且还会经常报错（如：超时、镜像不存在等错误）。&lt;br&gt;主要原因大家都知道：Registry在国内，网络影响太严重。还好国内的一些大企业对此做了些解决办法：加速器，比较常用的有阿里云和DaoCloud。要使用加速器都需要先注册一个对应的账号，我这里已经在这两个网站上都注册过了。&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://jasoncui.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jasoncui.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>离线安装docker最新版</title>
    <link href="http://jasoncui.com/2017/11/25/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker%E6%9C%80%E6%96%B0%E7%89%88/"/>
    <id>http://jasoncui.com/2017/11/25/离线安装docker最新版/</id>
    <published>2017-11-25T13:03:04.000Z</published>
    <updated>2018-03-10T07:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>离线安装Docker最新版<br></blockquote><a id="more"></a><p> 如果安装了以前版本，还要删除以下这个包。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container-selinux.noarch 2:2.10-2.el7</span><br></pre></td></tr></table></figure></p><p>离线安装三个rpm<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--. 1 root root 19524568 May 15 10:04 docker-ce-17.03.1.ce-1.el7.centos.x86_64.rpm</span><br><span class="line">-rw-r--r--. 1 root root 29108 May 15 10:04 docker-ce-selinux-17.03.1.ce-1.el7.centos.noarch.rpm</span><br><span class="line">-rw-r--r--. 1 root root 50076 May 16 08:32 libtool-ltdl-2.4.2-22.el7_3.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>下载地址：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://download.docker.com/linux/</span><br><span class="line">https://centos.pkgs.org/7/centos-updates-x86_64/libtool-ltdl-2.4.2-22.el7_3.x86_64.rpm.html</span><br><span class="line">http://mirror.centos.org/centos/7/updates/x86_64/Packages/libtool-ltdl-2.4.2-22.el7_3.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p> <img src="http://ojb6w1er1.bkt.clouddn.com/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85.png" alt="此处输入图片的描述"><br><img src="http://ojb6w1er1.bkt.clouddn.com/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%852.png" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;离线安装Docker最新版&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://jasoncui.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jasoncui.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装docker-compose</title>
    <link href="http://jasoncui.com/2017/11/21/CentOS7%E5%AE%89%E8%A3%85docker-compose/"/>
    <id>http://jasoncui.com/2017/11/21/CentOS7安装docker-compose/</id>
    <published>2017-11-21T13:03:04.000Z</published>
    <updated>2018-03-10T07:58:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>compose是用来在docker中定义和运行复杂应用的小工具,比如在一个文件中定义多个容器,只用一行命令就可以让一切就绪并运行.<br></blockquote><a id="more"></a><p>###安装pip:<br><img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose.png" alt="此处输入图片的描述"><br>这里显示，找不到相应的包？？<br>说没有python-pip软件包可以安装。<br>这是因为像centos这类衍生出来的发行版，他们的源有时候内容更新的比较滞后，或者说有时候一些扩展的源根本就没有。<br>所以在使用yum来search python-pip的时候，会说没有找到该软件包。因此为了能够安装这些包，需要先安装扩展源EPEL。<br>EPEL(<a href="http://fedoraproject.org/wiki/EPEL" target="_blank" rel="noopener">http://fedoraproject.org/wiki/EPEL</a>) 是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。<br>首先安装epel扩展源：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install epel-release</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose2.png" alt="此处输入图片的描述"><br>然后安装python-pip<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python2-pip.noarch</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose3.png" alt="此处输入图片的描述"><br>  <img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose4.png" alt="此处输入图片的描述"></p><p>###对安装好的pip进行一次升级<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install --upgrade pip</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose5.png" alt="此处输入图片的描述"><br>安装docker-compose<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose6.png" alt="此处输入图片的描述"><br>运行docker-compose<br><img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose7.png" alt="此处输入图片的描述"></p><p>出现报错<br>pkg_resources.DistributionNotFound: backports.ssl-match-hostname&gt;=3.5<br>使用pip 更新backports.ssl-match-hostname的版本<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade backports.ssl_match_hostname</span><br></pre></td></tr></table></figure></p><p>更新backports.ssl_match_hostname 到3.5版本后问题解决<br><img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose8.png" alt="此处输入图片的描述"><br><img src="http://ojb6w1er1.bkt.clouddn.com/%E5%AE%89%E8%A3%85dockercompose9.png" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;compose是用来在docker中定义和运行复杂应用的小工具,比如在一个文件中定义多个容器,只用一行命令就可以让一切就绪并运行.&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://jasoncui.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jasoncui.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>深入Java虚拟机学习之Java内存区域</title>
    <link href="http://jasoncui.com/2017/11/14/%E6%B7%B1%E5%85%A5Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://jasoncui.com/2017/11/14/深入Java虚拟机学习之Java内存区域/</id>
    <published>2017-11-14T13:03:04.000Z</published>
    <updated>2018-04-12T02:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>介绍Java虚拟机内存区域:方法区，堆，虚拟机栈，本地方法栈，程序计数器的概念以及引起OOM(OutOfMemeoryError)的潜在原因。<br></blockquote><a id="more"></a><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><blockquote><p>方法区(Method Area)是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。</p></blockquote><blockquote><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就和永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致的内存泄露。</p></blockquote><blockquote><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OOM异常。</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote><p>Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数据都要在堆上分配。但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量变换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不难么绝对了。</p></blockquote><blockquote><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p></blockquote><blockquote><p>“根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。”</p></blockquote><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><blockquote><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></blockquote><blockquote><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p></blockquote><blockquote><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p></blockquote><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><blockquote><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p></blockquote><blockquote><p>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分“实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p></blockquote><blockquote><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p></blockquote><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><blockquote><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p></blockquote><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><blockquote><p>“运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p></blockquote><blockquote><p>Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中[1]。</p></blockquote><blockquote><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OOM异常</p></blockquote><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><blockquote><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p></blockquote><blockquote><p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这“样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p></blockquote><blockquote><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p></blockquote><p>原文作者： 周志明 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;介绍Java虚拟机内存区域:方法区，堆，虚拟机栈，本地方法栈，程序计数器的概念以及引起OOM(OutOfMemeoryError)的潜在原因。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://jasoncui.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://jasoncui.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>笛卡尔积算法</title>
    <link href="http://jasoncui.com/2017/11/13/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://jasoncui.com/2017/11/13/笛卡尔积算法/</id>
    <published>2017-11-13T13:03:04.000Z</published>
    <updated>2018-06-01T03:22:59.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>笛卡尔积介绍。<br></blockquote><a id="more"></a><p>##STEP 1 : 什么是笛卡尔积<br>来自维基百科-笛卡儿积的解释:</p><blockquote><p>在数学中，两个集合X和Y的笛卡儿积（Cartesian product），又称直积，在集合论中表示为X × Y，是所有可能的有序对组成的集合，其中有序对的第一个对象是X的成员，第二个对象是Y的成员。</p></blockquote><p>来自百度百科-笛卡儿积的解释:</p><blockquote><p>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。</p></blockquote><p>举个比较常见的例子:</p><blockquote><p>如果集合X是13个元素的点数集合{ A, K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2 }，而集合Y是4个元素的花色集合{♠, ♥, ♦, ♣}，则这两个集合的笛卡儿积是有52个元素的标准扑克牌的集合{ (A, ♠), (K, ♠), …, (2, ♠), (A, ♥), …, (3, ♣), (2, ♣) }。</p></blockquote><p>##STEP 2 : java 实现笛卡尔积算法<br>实际上网络上有很多的笛卡尔积算法的实现,在此我就取其中一种方法进行演示:</p><ol><li>循环内，每次只有一列向下移一个单元格，就是CounterIndex指向的那列。</li><li>如果该列到尾部了，则这列index重置为0，而CounterIndex则指向前一列，相当于进位，把前列的index加一。</li><li>最后，由生成的行数来控制退出循环。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] x = &#123;<span class="string">"A"</span>, <span class="string">"K"</span>, <span class="string">"Q"</span>, <span class="string">"J"</span>, <span class="string">"10"</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"7"</span>, <span class="string">"6"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>, <span class="string">"3"</span>, <span class="string">"2"</span>&#125;;</span><br><span class="line">String[] y = &#123;<span class="string">"♠"</span>, <span class="string">"♥"</span>, <span class="string">"♦"</span>, <span class="string">"♣"</span>&#125;;</span><br><span class="line"></span><br><span class="line">      String[][] z = <span class="keyword">new</span> String[y.length][x.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y.length; i++) &#123;</span><br><span class="line">z[i] = x;</span><br><span class="line">&#125;</span><br><span class="line">String[][] temp = cartesianProduct(z);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">System.out.println(Arrays.toString(temp[i]));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(temp.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>private static String[][] cartesianProduct(String[][] args) {<br>int total = 1;<br>int counterIndex = args.length - 1;<br>int[] counter = new int[args.length];<br>for (int i = 0; i &lt; args.length; i++) {<br>total *= args[i].length;<br>counter[i] = 0;<br>}</p><p>String[][] result = new String[total][args.length];<br>for (int i = 0; i &lt; total; i++) {<br>for (int j = 0; j &lt; args.length; j++) {<br>result[i][j] = args[j][counter[j]];<br>}<br>counterIndex = handle(counter, counterIndex, args);<br>}<br>return result;<br>}</p><p>private static int handle(int[] counter, int counterIndex, String[][] args) {<br>counter[counterIndex]++;<br>if (counter[counterIndex] &gt;= args[counterIndex].length) {<br>counter[counterIndex] = 0;<br>counterIndex–;<br>if (counterIndex &gt;= 0) {<br>handle(counter, counterIndex, args);<br>}<br>counterIndex = args.length - 1;<br>}<br>return counterIndex;<br>}<br>}<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##STEP 3 : 笛卡尔积算法解决经典问题</span><br><span class="line">网络上有这样一个问题:</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">这九个按顺序排列的数，要求在它们之间插入若干个 + , - 或者什么都不加</span><br><span class="line">使其结果正好等于<span class="number">100</span></span><br><span class="line">我们可以使用笛卡尔积算法将所有的组合计算出来,然后取其中结果为<span class="number">100</span>的组合,具体实现如下:</span><br><span class="line">  ```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ScriptEngine jse = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">"JavaScript"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">String[] x = &#123;<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">""</span>&#125;;</span><br><span class="line">String[] y = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;;</span><br><span class="line"></span><br><span class="line">String[][] z = <span class="keyword">new</span> String[y.length][x.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y.length; i++) &#123;</span><br><span class="line">z[i] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算结果</span></span><br><span class="line">String[][] result = cartesianProduct(z);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result[i].length; j++) &#123;</span><br><span class="line">sb.append(y[j]);</span><br><span class="line">sb.append(result[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(y[y.length - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//利用js脚本引擎直接转换字符串为计算表达式,从而获得计算结果</span></span><br><span class="line">Object obj = jse.eval(sb.toString());</span><br><span class="line"><span class="keyword">if</span> (Integer.parseInt(String.valueOf(obj)) == <span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(sb.toString() + <span class="string">" = 100"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[][] cartesianProduct(String[][] args) &#123;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> counterIndex = args.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[args.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">total *= args[i].length;</span><br><span class="line">counter[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[][] result = <span class="keyword">new</span> String[total][args.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; args.length; j++) &#123;</span><br><span class="line">result[i][j] = args[j][counter[j]];</span><br><span class="line">&#125;</span><br><span class="line">counterIndex = handle(counter, counterIndex, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span>[] counter, <span class="keyword">int</span> counterIndex, String[][] args)</span> </span>&#123;</span><br><span class="line">counter[counterIndex]++;</span><br><span class="line"><span class="keyword">if</span> (counter[counterIndex] &gt;= args[counterIndex].length) &#123;</span><br><span class="line">counter[counterIndex] = <span class="number">0</span>;</span><br><span class="line">counterIndex--;</span><br><span class="line"><span class="keyword">if</span> (counterIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">handle(counter, counterIndex, args);</span><br><span class="line">&#125;</span><br><span class="line">counterIndex = args.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> counterIndex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原文作者： Maxith Zhou<br>原文链接 <a href="http://maxith.com/2017/08/30/cartesian-product/" target="_blank" rel="noopener">http://maxith.com/2017/08/30/cartesian-product/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;笛卡尔积介绍。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://jasoncui.com/categories/Java/"/>
    
    
      <category term="算法" scheme="http://jasoncui.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Mockito和SpringTest进行单元测试</title>
    <link href="http://jasoncui.com/2017/11/13/%E4%BD%BF%E7%94%A8Mockito%E5%92%8CSpringTest%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://jasoncui.com/2017/11/13/使用Mockito和SpringTest进行单元测试/</id>
    <published>2017-11-13T13:03:04.000Z</published>
    <updated>2018-03-10T07:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>单元测试的作用以及重要性其实不用在这里不断的重复了.为了保证软件的可靠性,单元测试可能是最容易执行的一个可靠的手段了.一方面，程序员通过编写单元测试来验证自己程序的有效性,另外一方面,管理者通过持续自动的执行单元测试和分析单元测试的覆盖率等来确保软件本身的质量.<br></blockquote><a id="more"></a><p>JAVA生态圈里面说起单元测试一般都会使用JUnit或者TestNG.其中JUnit可能使用的更加频繁一些,JUnit4使用注解以及各种其他框架对它的支持,形成了一个完善的单元测试的生态圈.</p><p>##SpringTest单元测试<br>现在的JAVA WEB项目中,起码一半以上的项目是使用了Spring的.因此,单纯的使用JUnit来进行单元测试并不是十分的好用,对于由Spring管理的Bean要进行单元测试,首先需要实例化Spring上下文,然后又需要手动的去注入依赖的Bean,比较麻烦.特别是对于有事务的单元测试,或数据库数据测试,单独使用JUnit几乎无法完成.<br>所幸,SpringFramework也意识到了这点,于是推出了spring-test模块,他能完成Spring环境与Junit单元测试环境的对接.让我们只专注于单元测试本身进行书写,而由它来完成Spring容器的初始化、Bean的获取、数据库事务的管理、数据操作正确性检查等等。<br>项目中引用spring-test<br>要在项目中使用Spring测试框架非常的简单，在Maven中依赖spring-test即可，Maven会自动的完成依赖包的引用：<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--test--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="创建单元测试类"><a href="#创建单元测试类" class="headerlink" title="创建单元测试类"></a>创建单元测试类</h2><p>Spring-test以及Junit4都推荐使用注解的方式来进行配置。因此，我们要进行单元测试，需要的就是创建一个自己的测试类。然后在类上面进行少许的注解，表明我们要如何初始化spring，需要引用spring的哪些配置，然后再指明需要在单元测试类中注入哪些bean即可，比如：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">// 整合Spring-Test与JUnit</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:application_bean_commons.xml"</span>,</span><br><span class="line"><span class="string">"classpath:application_bean_rmdbaccess.xml"</span>,</span><br><span class="line"><span class="string">"classpath:application_pm_service_poolmanage.xml"</span>&#125;) <span class="comment">// 加载需要的配置配置</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//事务回滚,便于重复测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoolService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IPoolService poolService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//可以在每一次单元测试前准备执行一些东西</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Pool pool = <span class="keyword">new</span> Pool();</span><br><span class="line">pool.setPoolName(<span class="string">"test_pool_001"</span>);</span><br><span class="line">pool.setDescription(<span class="string">"test add pool"</span>);</span><br><span class="line">pool = poolService.addPool(pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行结果的验证</span></span><br><span class="line">assertNotNull(pool.getId());</span><br><span class="line">assertNotNull(pool.getPoolCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  从这个简单的例子当中，我们可以看到和单独使用JUnit有几个不一样的地方。</p><pre><code>1. 首先使用了@RunWith(SpringJUnit4ClassRunner.class)来告诉JUnit，需要结合Spring-test来执行单元测试2. 然后使用@ContextConfiguration注解来告诉Spring-test这个单元测试最小需要依赖的spring的上下文是什么，因为通常单元测试不需要引入所有的spring配置，因此我们可以在这里可选的读取几个需要的配置即可3. 而后，我们可以在类上或者方法上使用@Transactional注解来标识某个或某些单元测试用例需要使用事务，并且可能会进行回滚，防止单元测试引起数据库脏数据。4. 同时，我们可以在这个单元测试类中直接使用@Autowired以及@Qualifier注解直接注入经过Spring管理过的依赖Bean。而我们测试的主要目的也就是对这些bean进行单元测试。5. 剩下的就和单独的使用JUnit进行单元测试是一样的了。</code></pre><p>经过以上的处理，我们就可以进行spring框架下的单元测试了，而且基本上能满足80%以上的需求。更多更高级的用法，可以参考：<a href="http://junit.org/junit4/" target="_blank" rel="noopener">JUnit官网</a>以及<a href="http://docs.spring.io/spring/docs/4.3.4.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#overview-testing" target="_blank" rel="noopener">Spring-test官网</a></p><p>##基于数据库数据的单元测试数据准备<br>其实这个和要讲的Spring-test没有必然的联系。但是在很多的情况下，我们都会对数据库访问层进行单元测试。那么，往往就涉及到了数据库的数据打桩。为了能实现单元测试的自动化和可重复化，我们可以把桩数据写入一个单元测试的SQL中，在每次执行单元测试的时候，先执行这个SQL，给数据库准备数据，然后再执行单元测试。而这一切，我们可以写一个测试的基类来进行处理（JDK1.8中允许给接口增加默认方法，因此，这个地方我们可以定义一个接口来实现这个功能）：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DBTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的默认方法，对数据库进行打桩</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">prepareRmdbData</span><span class="params">(SimpleRmdbDao simpleRmdbDao)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String content = sqlForThisTest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (content==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String[] sqlLines = content.split(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String sqlLine : sqlLines) &#123;</span><br><span class="line">simpleRmdbDao.executeDDL(sqlLine);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析和这个测试类相同名字的SQL，一行一句。</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">sqlForThisTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String sqlName = getClass().getSimpleName() + <span class="string">".sql"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">List&lt;String&gt; lines = IOUtils.readLines(getClass().getResourceAsStream(sqlName),<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*去掉SQL中的注释*/</span></span><br><span class="line">Optional&lt;String&gt; optional = lines.parallelStream().filter(s -&gt; !(s.startsWith(<span class="string">"-- "</span>)&amp;&amp;s.endsWith(<span class="string">" --"</span>)))</span><br><span class="line">.reduce(String::concat);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optional.isPresent())&#123;</span><br><span class="line"><span class="keyword">return</span> optional.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了这个接口，我们在写单元测试类的时候，就可以直接实现这个接口，然后在@Before方法中调用prepareRmdbData方法来初始化数据库:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">// 整合Spring-Test与JUnit</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:application_bean_commons.xml"</span>,</span><br><span class="line"><span class="string">"classpath:application_bean_rmdbaccess.xml"</span>,</span><br><span class="line"><span class="string">"classpath:application_pm_service_poolmanage.xml"</span>&#125;) <span class="comment">// 加载需要的配置配置</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//事务回滚,便于重复测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoolService</span> <span class="keyword">implements</span> <span class="title">DBTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IPoolService poolService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SimpleRmdbDao simpleRmdbDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//可以在每一次单元测试前准备执行一些东西</span></span><br><span class="line">         prepareRmdbData(simpleRmdbDao);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeletePool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//case1</span></span><br><span class="line">Pool pool = poolService.getPoolByCode(<span class="string">"P-00003"</span>);</span><br><span class="line"></span><br><span class="line">assertNotNull(pool);</span><br><span class="line"></span><br><span class="line">poolService.deletePool(<span class="string">"P-00003"</span>);</span><br><span class="line"></span><br><span class="line">pool = poolService.getPoolByCode(<span class="string">"P-00003"</span>);</span><br><span class="line"></span><br><span class="line">assertNull(pool);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后把SQL文件命名为TestPoolService.sql,放入test/resources中即可。<br>Mock测试<br>经过上面所说的JUnit+SpringTest,基本上可以满足80%的单元测试了。但是，由于现在的系统越来越复杂，相互之间的依赖越来越多。特别是微服务化以后的系统，往往一个模块的代码需要依赖几个其他模块的东西。因此，在做单元测试的时候，往往很难构造出需要的依赖。一个单元测试，我们只关心一个小的功能，但是为了这个小的功能能跑起来，可能需要依赖一堆其他的东西，这就导致了单元测试无法进行。所以，我们就需要再测试过程中引入Mock测试。<br>所谓的Mock测试就是在测试过程中，对于一些不容易构造的、或者和这次单元测试无关但是上下文又有依赖的对象，用一个虚拟的对象（Mock对象）来模拟，以便单元测试能够进行。<br>比如有一段代码的依赖为：<br><img src="http://ojb6w1er1.bkt.clouddn.com/Mockito1.jpg" alt="此处输入图片的描述"><br>当我们要进行单元测试的时候，就需要给A注入B和C,但是C又依赖了D，D又依赖了E。这就导致了，A的单元测试很难得进行。<br>但是，当我们使用了Mock来进行模拟对象后，我们就可以把这种依赖解耦，只关心A本身的测试，它所依赖的B和C，全部使用Mock出来的对象，并且给MockB和MockC指定一个明确的行为。就像这样：</p><p><img src="http://ojb6w1er1.bkt.clouddn.com/Mockito2.jpg" alt="此处输入图片的描述"><br>因此，当我们使用Mock后，对于那些难以构建的对象，就变成了个模拟对象，只需要提前的做Stubbing（桩）即可，所谓做桩数据，也就是告诉Mock对象，当与之交互时执行何种行为过程。比如当调用B对象的b()方法时，我们期望返回一个true，这就是一个设置桩数据的预期。</p><p>##Mockito简单入门<br>在JAVA中，Mock测试框架主要有Mockito,Jmock,EsayMock,PowerMock等等。其中Mockito最为方便和简单，用的人也最多。而PowerMock是对Mockito的一个增强,增加了对静态、final、私有方法的Mock，但是基本用法和Mockito大致相同。对因此，我们使用Mockito作为Mock的框架。<br>项目中引用Mockito<br>要在项目中使用Mockito非常的简单，只需要在项目的Maven中引入：<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>###使用Mockito进行测试<br>我们这里使用一个最简单的用户基本信息管理来做演示。这个功能有一个模型对象UserPO,一个数据库访问层UserDao,一个服务层UserService。<br><em>UserPO</em><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>UserDao</em><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">updateUser</span><span class="params">(UserPO userPO)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPO <span class="title">getUserById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>UserService</em><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateUserName</span><span class="params">(Long userId,String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">UserPO userPO = userDao.getUserById(userId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (userPO==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userPO.setName(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userDao.updateUser(userPO);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###创建单元测试类<br>当我们准备好上面的例子后，就可以开始创建单元测试类了。<br>在这里，我们假设IUserDao是个很复杂的访问集群数据库的对象，并且这个类已经经过完整的测试保证是正确了的。而我们现在只需要单元测试UserService#updateUserName这个方法。因此，就需要对IUserDao进行Mock并打桩。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//对注解了@Mock的对象进行模拟</span></span><br><span class="line">MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造被测试对象</span></span><br><span class="line">userService = <span class="keyword">new</span> UserService();</span><br><span class="line">userService.setUserDao(userDao);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据打桩。 当调用 userDao.getUserById(1L)时，返回一个UserPO</span></span><br><span class="line">Mockito.when(userDao.getUserById(<span class="number">1L</span>)).thenReturn(<span class="keyword">new</span> UserPO(<span class="number">1L</span>,<span class="string">"user1"</span>,<span class="number">20</span>));</span><br><span class="line"><span class="comment">// 当调用 userDao.getUserById(2L)时，返回一个null，表示用户不存在</span></span><br><span class="line">Mockito.when(userDao.getUserById(<span class="number">2L</span>)).thenReturn(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用userDao.updateUser(userPO)的时候，返回一个true</span></span><br><span class="line">Mockito.when(userDao.updateUser(Mockito.any())).thenReturn(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateUserNameSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*成功的情况*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试这个被测试对象的方法*/</span></span><br><span class="line"><span class="keyword">boolean</span> updated = userService.updateUserName(<span class="number">1L</span>,<span class="string">"user_new"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证结果</span></span><br><span class="line">Assert.assertTrue(updated);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证userDao的getUserById(1L)这个方法是否被调用过</span></span><br><span class="line">Mockito.verify(userDao).getUserById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造参数捕获器，用于捕获方法参数进行验证</span></span><br><span class="line">ArgumentCaptor&lt;UserPO&gt; personCaptor = ArgumentCaptor.forClass( UserPO.class );</span><br><span class="line"><span class="comment">//验证updateUser方法是否被调用过，并且捕获入参</span></span><br><span class="line">Mockito.verify(userDao).updateUser(personCaptor.capture());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回捕获的参数。</span></span><br><span class="line">UserPO updatedPerson = personCaptor.getValue();</span><br><span class="line"><span class="comment">//判断是否已经被修改过了</span></span><br><span class="line">Assert.assertEquals(<span class="string">"user_new"</span>, updatedPerson.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//多余方法调用验证，保证这个测试用例中所有被Mock的对象的相关方法都已经被Verify过了</span></span><br><span class="line">Mockito.verifyNoMoreInteractions(userDao);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateUserNameFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*测试这个被测试对象的方法*/</span></span><br><span class="line"><span class="keyword">boolean</span> updated = userService.updateUserName(<span class="number">2L</span>,<span class="string">"user_new"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证结果</span></span><br><span class="line">Assert.assertFalse(updated);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证userDao的getUserById(1L)这个方法是否被调用过</span></span><br><span class="line">Mockito.verify(userDao).getUserById(<span class="number">2L</span>);</span><br><span class="line"><span class="comment">//多余方法调用验证，保证这个测试用例中所有被Mock的对象的相关方法都已经被Verify过了</span></span><br><span class="line">Mockito.verifyZeroInteractions(userDao);</span><br><span class="line"><span class="comment">//多余方法调用验证，保证这个测试用例中所有被Mock的对象的相关方法都已经被Verify过了</span></span><br><span class="line">Mockito.verifyNoMoreInteractions(userDao);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  上面的代码就是一个完整的单元测试类，有两个用例，分别验证当用户存在能修改名字的情况以及用户不存在修改名字失败的情况。<br>我们从头来分析一下这个单元测试类。</p><p>###标明需要Mock的对象<br>程序一来，先定义了被测试的对象实例userService以及需要被模拟的IUserDao对象。需要注意的是，我们在userDao成员变量上增加了一个@Mock注解。这个注解的作用就是告诉Mockito，这个对象是需要被Mock的。<br>接着，我们创建了一个setUp()方法，并使用了JUnit的注解@Before，用于在执行单元测试前执行一些代码，我们在这里需要对Mock的对象进行打桩。<br>MockitoAnnotations.initMocks(this);这句话就是对所有标注了@Mock注解的对象进行模拟。当然，我们也可以不使用注解，而直接使用代码的方式手动的初始化Mock的对象：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//对注解了@Mock的对象进行模拟</span></span><br><span class="line"><span class="comment">// MockitoAnnotations.initMocks(this);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用手动的方式进行Mock</span></span><br><span class="line">userDao = Mockito.mock(IUserDao.class);</span><br></pre></td></tr></table></figure></p><p>  接着就是指定userDao的行为也就是桩了。这也是Mockito最常用最核心的方法了。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//数据打桩。 当调用 userDao.getUserById(1L)时，返回一个UserPO</span></span><br><span class="line">Mockito.when(userDao.getUserById(<span class="number">1L</span>)).thenReturn(<span class="keyword">new</span> UserPO(<span class="number">1L</span>,<span class="string">"user1"</span>,<span class="number">20</span>));</span><br><span class="line"><span class="comment">// 当调用 userDao.getUserById(2L)时，返回一个null，表示用户不存在</span></span><br><span class="line">Mockito.when(userDao.getUserById(<span class="number">2L</span>)).thenReturn(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用userDao.updateUser(userPO)的时候，返回一个true</span></span><br><span class="line">Mockito.when(userDao.updateUser(Mockito.any())).thenReturn(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>  Mockito最基本的用法就是调用 when以及thenReturn方法了。他们的作用就是指定当我们调用被代理的对象的某一个方法以及参数的时候，返回什么值。</p><ul><li>比如第一句的Mockito.when(userDao.getUserById(1L)).thenReturn(new UserPO(1L,”user1”,20));就表明，当我调用userDao.getUserById(1L)的时候，这个方法返回new UserPO(1L,”user1”,20)这个实例。</li><li>当我们需要返回NULL的时候，也非常的简单，直接写成thenReturn(null)即可。</li><li>如果我们不关心调用的参数的入参，那么Mockito提供了几个方法来表示:any()、any(Class<t> type)、anyBoolean()、anyByte()、anyChar()、anyInt()、anyLong()、anyFloat()、anyDouble()、anyShort()、anyString()、anyList()、anyListOf(Class<t> clazz)、anySet()、anyMap()等等</t></t></li><li>相反，Mockito还提供了很强大的入参过滤，用于指定只对某一些入参的调用进行Mock。比如：正则表达式Mockito.matches(“.*User$”))、开头结尾验证endsWith(String suffix) startsWith(String prefix)、判空验证isNotNull() isNull()</li><li>甚至，我们还可以自定义入参匹配：argThat(ArgumentMatcher<t> matcher)。ArgumentMatcher只有一个方法boolean matches(T argument);传入入参，返回一个boolean表示是否匹配。在JDK1.8中，我们可以使用lambda表达式来自定义入参匹配，比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mockito.argThat(argument -&gt; argument <span class="keyword">instanceof</span> UserPO);</span><br></pre></td></tr></table></figure></t></li></ul><p>除了我们期望调用一个方法后返回一个值外，有些时候，我们可能期望他抛出一个异常。这个时候，我们可以调用thenThrow(Throwable… throwables); 用来抛出异常，这个方法有三个重载:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* thenThrow(Throwable... throwables): 直接指定抛出的异常实例</span><br><span class="line">* thenThrow(Class&lt;? extends Throwable&gt; throwableType): 指定抛出异常的类型，执行的时候动态的实例化一个异常实例</span><br><span class="line">* thenThrow(Class&lt;? extends Throwable&gt; toBeThrown, Class&lt;? extends Throwable&gt;... nextToBeThrown): 多次调用，依次抛出异常</span><br></pre></td></tr></table></figure></p><p>//当调用userDao的更新时，如果传入的用户的名字是admin，那么就不允许修改，直接抛出异常<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mockito.when(userDao.updateUser(Mockito.argThat(argument -&gt; argument.getName().equals(<span class="string">"admin"</span>)))).thenThrow(IllegalArgumentException.class);</span><br></pre></td></tr></table></figure></p><ul><li>此外，Mockito还提供了两个表示行为的方法：thenAnswer(Answer&lt;?&gt; answer);、thenCallRealMethod();,分别表示自定义处理调用后的行为，以及调用真实的方法。这两个方法在有些测试用例中还是很有用的。</li><li>对于同一个方法，Mockito可以是顺序与次数关心的。也就是说可以实现同一个方法，第一次调用返回一个值，第二次调用返回一个值，甚至第三次调用抛出异常等等。只需要连续的调用thenXXXX即可。</li><li>最后，还有一个需要说明的就是如果为一个返回为Void的方法设置桩数据。上面的方法都是表示的是有返回值的方法，而由于一个方法没有返回值，因此我们不能调用when方法(编译器不允许)。因此，对于无返回值的方法，Mockito提供了一些列的doXXXXX方法，比如：doAnswer(Answer answer)、doNothing()、doReturn(Object toBeReturned)、doThrow(Class&lt;? extends Throwable&gt; toBeThrown)、doCallRealMethod()。他们的使用方法其实和上面的thenXXXX是一样的，但是when方法传入的是Mock的对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*对void的方法设置模拟*/</span></span><br><span class="line">Mockito.doAnswer(invocationOnMock -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"进入了Mock"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;).when(fileRecordDao).insert(Mockito.any());</span><br></pre></td></tr></table></figure></li></ul><p>###验证Mock对象的调用<br>其实，一个最简单的Mock单元测试到这里已经算是完成了。我们已经验证了userService中的方法的正确性。但是，在复杂的方法调用堆栈中，往往可能出现结果正确，但是过程不正确的情况。比如，updateUserName方法返回false是有两种可能的，一种可能是用户没有找到，还有一种可能就是userDao.updateUser(userPO)返回false。因此，如果我们只是使用Assert.assertFalse(updated);来验证结果，可能就会忽略某些错误。<br>Mockito同时提供了一些列的方法来对调用过程中的Mock对象的方法调用进行跟踪。我们可以对这些调用的过程进行断言验证，保证单元测试的结果与过程都是符合我们预期的。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateUserNameSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*成功的情况*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试这个被测试对象的方法*/</span></span><br><span class="line"><span class="keyword">boolean</span> updated = userService.updateUserName(<span class="number">1L</span>,<span class="string">"user_new"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证结果</span></span><br><span class="line">Assert.assertTrue(updated);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证userDao的getUserById(1L)这个方法是否被调用过</span></span><br><span class="line">Mockito.verify(userDao).getUserById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造参数捕获器，用于捕获方法参数进行验证</span></span><br><span class="line">ArgumentCaptor&lt;UserPO&gt; personCaptor = ArgumentCaptor.forClass( UserPO.class );</span><br><span class="line"><span class="comment">//验证updateUser方法是否被调用过，并且捕获入参</span></span><br><span class="line">Mockito.verify(userDao).updateUser(personCaptor.capture());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回捕获的参数。</span></span><br><span class="line">UserPO updatedPerson = personCaptor.getValue();</span><br><span class="line"><span class="comment">//判断是否已经被修改过了</span></span><br><span class="line">Assert.assertEquals(<span class="string">"user_new"</span>, updatedPerson.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//多余方法调用验证，保证这个测试用例中所有被Mock的对象的相关方法都已经被Verify过了</span></span><br><span class="line">Mockito.verifyNoMoreInteractions(userDao);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Mockito.verify(userDao).getUserById(1L);方法即验证了getUserById(1L)这个方法是否被调用过，如果没有被调用过(包括入参要一致)，就会抛出异常。</li><li>除了最简单的verify(T mock)方法外，还提供了verify(T mock, VerificationMode mode)方法。第二个参数有很多默认的实现，用于满足不同的需求。比如：Mockito.verify(userDao,Mockito.times(1)).getUserById(1L); 表示调用第一次 是传入的getUserById(1L);，Mockito.verify(userDao,Mockito.times(2)).getUserById(2L);表示调用第二次是传入的getUserById(2L);，如果测试用例的调用顺序与参数不满足的话，就会报错。</li><li>除了times函数外，还提供了after、atLeast、only、atMost、timeout等等。</li><li>verifyZeroInteractions和verifyNoMoreInteractions这两个方法的实现其实是一样的，只是名字不一样，作用就是验证被Mock的对象的所有被调用的方法是否都被Verify过了。这样就能保证调用没有被遗漏。当有方法被调用了，但是我们在测试用例中没有verify的话，那么调用这两个方法就会抛异常。<br>##Mockito与SpringTest整合<br>经过前面的讲解，Mockito的基本用法基本上应该都了解了。那么现在就需要整合Mockito和SpringTest了。<br>其实这两者的整合也非常的简单。和他们单独使用的时候并没有什么区别。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">// 整合Spring-Test与JUnit</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:application_bean_commons.xml"</span>,</span><br><span class="line"><span class="string">"classpath:application_bean_rmdbaccess.xml"</span>,</span><br><span class="line"><span class="string">"classpath:application_pm_service_poolmanage.xml"</span>&#125;) <span class="comment">// 加载需要的配置配置</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//事务回滚,便于重复测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoolService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IPoolService poolService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> IPoolDao poolDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//可以在每一次单元测试前准备执行一些东西</span></span><br><span class="line">         MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把Spring上下文注入的对象给替换掉</span></span><br><span class="line">         ReflectionTestUtils.setField(AopTargetUtils.getTarget(poolService), ”poolDao“,poolDao);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对void的方法设置模拟*/</span></span><br><span class="line">Mockito.doAnswer(invocationOnMock -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"进入了Mock"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;).when(poolDao).insert(Mockito.any());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Pool pool = <span class="keyword">new</span> Pool();</span><br><span class="line">pool.setPoolName(<span class="string">"test_pool_001"</span>);</span><br><span class="line">pool.setDescription(<span class="string">"test add pool"</span>);</span><br><span class="line">pool = poolService.addPool(pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行结果的验证</span></span><br><span class="line">assertNotNull(pool.getId());</span><br><span class="line">assertNotNull(pool.getPoolCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>与单独使用Mockito相比，最大的不同其实就是在setUp()方法中调用的ReflectionTestUtils.setField(AopTargetUtils.getTarget(poolService), ”poolDao“,poolDao);这个方法。ReflectionTestUtils是Spring-test提供的一个用于反射处理测试类的工具，通过这个，我们可以替换某一个被spring所管理的bean的成员变量。把他换成我们Mock出来的模拟对象。<br>当然这又引出了一个问题，就是如果依赖的对象的依赖对象需要被Mock，那么手动的不断重复的找需要被Mock的成员变量非常的麻烦。因此，我们可以写一个AbstractTestExecutionListener监听器，当注入依赖的时候，找到被Mock的变量，以及需要被注入的变量，然后做关系的依赖。这样就能自动的对成员变量做替换了。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoDependencyInjectionTestExecutionListener</span> <span class="keyword">extends</span> <span class="title">DependencyInjectionTestExecutionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class,Object&gt; mockObject = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">injectDependencies</span><span class="params">(<span class="keyword">final</span> TestContext testContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.injectDependencies(testContext);</span><br><span class="line">init(testContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectMock</span><span class="params">(Object bean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Field[] fields;</span><br><span class="line"><span class="comment">/*找到所有的测试用例的字段*/</span></span><br><span class="line"><span class="keyword">if</span> (AopUtils.isAopProxy(bean))&#123;</span><br><span class="line"><span class="comment">// 如果是代理的话，找到真正的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(AopUtils.isJdkDynamicProxy(bean)) &#123;</span><br><span class="line">Class targetClass = AopTargetUtils.getTarget(bean).getClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 可能是远程实现</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fields = targetClass.getDeclaredFields();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//cglib</span></span><br><span class="line"><span class="comment">/*CGLIB的代理 不支持*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fields = bean.getClass().getDeclaredFields();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Field&gt; injectFields = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断字段上的注解*/</span></span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">Annotation[] annotations = field.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (Annotation antt : annotations) &#123;</span><br><span class="line"><span class="comment">/*如果是Mock字段的,就直接注入Mock的对象*/</span></span><br><span class="line"><span class="keyword">if</span> (antt <span class="keyword">instanceof</span> org.mockito.Mock) &#123;</span><br><span class="line"><span class="comment">// 注入mock实例</span></span><br><span class="line">Object mockObj = mock(field.getType());</span><br><span class="line">mockObject.put(field.getType(),mockObj);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(bean, mockObj);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (antt <span class="keyword">instanceof</span> Autowired) &#123;</span><br><span class="line"><span class="comment">/*需要把所有标注为autowired的找到*/</span></span><br><span class="line">injectFields.add(field);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*访问每一个被注入的实例*/</span></span><br><span class="line"><span class="keyword">for</span> (Field field : injectFields) &#123;</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*找到每一个字段的值*/</span></span><br><span class="line">Object object = field.get(bean);</span><br><span class="line"></span><br><span class="line">Class targetClass = field.getType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!replaceInstance(targetClass,bean,field.getName()))&#123;</span><br><span class="line"><span class="comment">//如果没有被mock过.那么这个字段需要再一次的做递归</span></span><br><span class="line">injectMock(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">replaceInstance</span><span class="params">(Class targetClass, Object bean, String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> beMocked = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Class, Object&gt; classObjectEntry : mockObject.entrySet()) &#123;</span><br><span class="line">Class type = classObjectEntry.getKey();</span><br><span class="line"><span class="keyword">if</span> (type.isAssignableFrom(targetClass))&#123;</span><br><span class="line"><span class="comment">//如果这个字段是被mock了的对象.那么就使用这个mock的对象来替换</span></span><br><span class="line">ReflectionTestUtils.setField(AopTargetUtils.getTarget(bean), fieldName, classObjectEntry.getValue());</span><br><span class="line">beMocked = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beMocked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> TestContext testContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object bean = testContext.getTestInstance();</span><br><span class="line"></span><br><span class="line">injectMock(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  以上代码即为Mock初始化的监听器。它会查询这个测试用例的所有的成员变量。找到被标记为@Mock的变量，然后模拟出来。而后，又找到所有被标注为@Autowired的成员变量，判断变量类型是否是需要被Mock的。<br>当需要使用这个监听器的时候，只需要增加一个注解@TestExecutionListeners即可：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class="comment">// 整合Spring-Test与JUnit</span></span><br><span class="line"><span class="comment">/*如果要加事物,那么当手动设置TestExecutionListeners的时候,需要把TransactionalTestExecutionListener这个也加上*/</span></span><br><span class="line"><span class="meta">@TestExecutionListeners</span>(&#123; MockitoDependencyInjectionTestExecutionListener.class, TransactionalTestExecutionListener.class &#125;)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:application_bean_commons.xml"</span>,</span><br><span class="line"><span class="string">"classpath:application_bean_rmdbaccess.xml"</span>,</span><br><span class="line"><span class="string">"classpath:application_pm_service_poolmanage.xml"</span>&#125;) <span class="comment">// 加载需要的配置配置</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//事务回滚,便于重复测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoolService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> IPoolService poolService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> IPoolDao poolDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">         <span class="comment">/*对void的方法设置模拟*/</span></span><br><span class="line">Mockito.doAnswer(invocationOnMock -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"进入了Mock"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;).when(poolDao).insert(Mockito.any());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Pool pool = <span class="keyword">new</span> Pool();</span><br><span class="line">pool.setPoolName(<span class="string">"test_pool_001"</span>);</span><br><span class="line">pool.setDescription(<span class="string">"test add pool"</span>);</span><br><span class="line">pool = poolService.addPool(pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行结果的验证</span></span><br><span class="line">assertNotNull(pool.getId());</span><br><span class="line">assertNotNull(pool.getPoolCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;单元测试的作用以及重要性其实不用在这里不断的重复了.为了保证软件的可靠性,单元测试可能是最容易执行的一个可靠的手段了.一方面，程序员通过编写单元测试来验证自己程序的有效性,另外一方面,管理者通过持续自动的执行单元测试和分析单元测试的覆盖率等来确保软件本身的质量.&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://jasoncui.com/categories/Java/"/>
    
    
      <category term="单元测试" scheme="http://jasoncui.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器访问外部网络</title>
    <link href="http://jasoncui.com/2017/10/19/Docker%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C/"/>
    <id>http://jasoncui.com/2017/10/19/Docker容器访问外部网络/</id>
    <published>2017-10-19T13:03:04.000Z</published>
    <updated>2018-03-10T07:58:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>最近工作中部署一个项目，在项目内部需要访问外网。给某云上传文件，但是一直报unknown host，无法解析域名，然后找了好久原因，下面废话不多说，来一起看看详细的解决方法。<br></blockquote><a id="more"></a><p>##解决方法<br>Linux系统默认没有打开IP转发功能，要确认IP转发功能的状态，可以查看/proc文件系统，使用下面命令：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>如果上述文件中的值为0,说明禁止进行IP转发；如果是1,则说明IP转发功能已经打开,要想打开IP转发功能，可以直接修改上述文件：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></p><p>把文件的内容由0修改为1。禁用IP转发则把1改为0。<br>上面的命令并没有保存对IP转发配置的更改，下次系统启动时仍会使用原来的值，要想永久修改IP转发，需要修改/etc/sysctl.conf文件，修改下面一行的值：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure></p><p>修改后可以重启系统来使修改生效，也可以执行下面的命令来使修改生效：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p><p>进行了上面的配置后，IP转发功能就永久开启了</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;最近工作中部署一个项目，在项目内部需要访问外网。给某云上传文件，但是一直报unknown host，无法解析域名，然后找了好久原因，下面废话不多说，来一起看看详细的解决方法。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://jasoncui.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jasoncui.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker开启远程API</title>
    <link href="http://jasoncui.com/2017/10/19/Docker%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8BAPI/"/>
    <id>http://jasoncui.com/2017/10/19/Docker开启远程API/</id>
    <published>2017-10-19T13:03:04.000Z</published>
    <updated>2018-03-10T07:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>有时需要远程调用DockerAPI进行容器操作，比如Jenkins，本文讲述如何开启Docker远程API。<br></blockquote><a id="more"></a><ul><li>修改配置文件 CentOS6:<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/docker</span><br></pre></td></tr></table></figure></li></ul><p>添加一行:<br>  <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">'-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock'</span></span><br></pre></td></tr></table></figure></p><p>CentOS7:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure></p><p>修改一行:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure></p><ul><li><p>重启Docker </p><ul><li><p>CentOS6:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><ul><li>CentOS7:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>测试<br>在本机 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:2375/info</span><br></pre></td></tr></table></figure></li></ul><p>在其他机器上：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://hostanme:2375/info</span><br></pre></td></tr></table></figure></p><ul><li>此时本地client可以继续通过Unix sock与docker daemon通行<br>例如：docker info 命令继续有效。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;有时需要远程调用DockerAPI进行容器操作，比如Jenkins，本文讲述如何开启Docker远程API。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://jasoncui.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jasoncui.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>细思极恐-你真的会写java吗?</title>
    <link href="http://jasoncui.com/2017/10/13/%E7%BB%86%E6%80%9D%E6%9E%81%E6%81%90-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99java%E5%90%97/"/>
    <id>http://jasoncui.com/2017/10/13/细思极恐-你真的会写java吗/</id>
    <published>2017-10-13T13:03:04.000Z</published>
    <updated>2018-03-10T07:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>本文转载自一位优秀程序猿，笔者是一个务实的程序员，故本文绝非扯淡文章，文中内容都是干货，望读者看后，能有所收获。<br></blockquote><a id="more"></a><h2 id="文章核心"><a href="#文章核心" class="headerlink" title="文章核心"></a>文章核心</h2><p>其实，本不想把标题写的那么恐怖，只是发现很多人干了几年java以后，都自认为是一个不错的java程序员了，可以拿着上万的工资都处宣扬自己了，写这篇文章的目的并不是嘲讽和我一样做java的同行们，只是希望读者看到此骗文章后，可以和我一样，心平气和的争取做一个优秀的程序员。</p><h2 id="讲述方向"><a href="#讲述方向" class="headerlink" title="讲述方向"></a>讲述方向</h2><p>由于一直从事移动互联网相关工作，java开发中经常和移动端打交道或者做一些后端的工作，所以本篇文章更可能涉及和移动端的交互或者与后端的交互方式，笔者希望以自身的一些学习经验或者开发经验，可以带动认真阅读本篇文章的读者们，让大家对java有一个更好的态度去学习它，它不只是一个赚钱的工具而已。<br>笔者身边有很多与笔者年龄相仿或年龄更大的朋友或同事，经常有人问我：“你现在还在学习吗？我觉得没什么好学的，这些东西都差不多”，我总是回答只要有时间，我就要看一会书，这个时候，大家都会露出一副不屑的眼神或笑容。其实，非常能理解身边朋友或同事的看法，以目前状态来讲，大多都是工作至少5年的程序员了，对于公司大大小小的业务需要，以目前的知识储备来讲，都可以轻松应对，“没有什么好学的”其实这句话没有多大的问题，但是，如果你对编程还有一点点兴趣，只是不知道如何努力或改进，希望本篇文章可以帮到你。</p><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><p>本文不是一个吹嘘的文章，不会讲很多高深的架构，相反，会讲解很多基础的问题和写法问题，如果读者自认为基础问题和写法问题都是不是问题，那请忽略这篇文章，节省出时间去做一些有意义的事情。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>不知道有多少”老”程序员还在使用eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，eclipse吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。</p><h3 id="更换IDE"><a href="#更换IDE" class="headerlink" title="更换IDE"></a>更换IDE</h3><p>根本就不想多解释要换什么样的IDE，如果你想成为一个优秀的java程序员，请更换intellij idea. 使用idea的好处，请搜索谷歌。</p><h3 id="别告诉我快捷键不好用"><a href="#别告诉我快捷键不好用" class="headerlink" title="别告诉我快捷键不好用"></a>别告诉我快捷键不好用</h3><p>更换IDE不在我本文的重点内容中，所以不下想用太多的篇幅去写为什么更换IDE，请谷歌。<br>在这里，我只能告诉你，更换IDE只为了更好、更快的写好java代码。原因略。<br>别告诉我快捷键不好用，请尝试新事物。</p><h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><p>bean使我们使用最多的模型之一，我将以大篇幅去讲解bean，希望读者好好体会。</p><h3 id="domain包名"><a href="#domain包名" class="headerlink" title="domain包名"></a>domain包名</h3><p>根据很多java程序员的”经验”来看，一个数据库表则对应着一个domain对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是domain。但是你错了，domain是一个领域对象，往往我们再做传统java软件web开发中，这些domain都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些domain都应该是一个普通的entity对象，并非领域对象，所以请把包名改为:com.xxx.entity。<br>如果你还不理解我说的话，请看一下Vaughn Vernon出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》(实现领域驱动设计)这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。</p><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>数据传输我们应该使用DTO对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端api设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为DTO对象。请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是DTO对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到OMS 或者 ERP系统，这些对接的返回值以及入参也叫DTO对象。<br>我们约定某对象如果是DTO对象，就将名称改为XXDTO,比如订单下发OMS：OMSOrderInputDTO。</p><h3 id="DTO转化"><a href="#DTO转化" class="headerlink" title="DTO转化"></a>DTO转化</h3><p>正如我们所知，DTO为系统与外界交互的模型对象，那么肯定会有一个步骤是将DTO对象转化为BO对象或者是普通的entity对象，让service层去处理。</p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/v1/api/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">(UserInputDTO userInputDTO)</span></span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(userInputDTO.getUsername());</span><br><span class="line">user.setAge(userInputDTO.getAge());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userService.addUser(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们只关注一下上述代码中的转化代码，其他内容请忽略:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(userInputDTO.getUsername());</span><br><span class="line">user.setAge(userInputDTO.getAge());</span><br></pre></td></tr></table></figure></p><h3 id="请使用工具"><a href="#请使用工具" class="headerlink" title="请使用工具"></a>请使用工具</h3><p>上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有20个字段，我们要如何做呢？ 一个一个进行set数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。<br>网上有很多工具，支持浅拷贝或深拷贝的Utils. 举个例子，我们可以使用org.springframework.beans.BeanUtils#copyProperties对代码进行重构和优化:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">(UserInputDTO userInputDTO)</span></span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userService.addUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BeanUtils.copyProperties是一个浅拷贝方法，复制属性时，我们只需要把DTO对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做DTO转化的时候一直使用set进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰!</p><h3 id="转化的语义"><a href="#转化的语义" class="headerlink" title="转化的语义"></a>转化的语义</h3><p>上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写java代码时，更多的需要考虑语义的操作，再看上边的代码:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br></pre></td></tr></table></figure></p><p>虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好,所以代码改成如下:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">(UserInputDTO userInputDTO)</span></span>&#123;</span><br><span class="line">User user = convertFor(userInputDTO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userService.addUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">convertFor</span><span class="params">(UserInputDTO userInputDTO)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = convertFor(userInputDTO);</span><br><span class="line"><span class="keyword">return</span> userService.addUser(user);</span><br></pre></td></tr></table></figure></p><p>这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。<br>如上所述，是一种重构方式，读者可以参考Martin Fowler的《Refactoring Imporving the Design of Existing Code》(重构 改善既有代码的设计) 这本书中的Extract Method重构方式。</p><h3 id="抽象接口定义"><a href="#抽象接口定义" class="headerlink" title="抽象接口定义"></a>抽象接口定义</h3><p>当实际工作中，完成了几个api的DTO转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。<br>如果接口被定义以后，那么convertFor这个方法的语义将产生变化，他将是一个实现类。<br>看一下抽象后的接口:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DTOConvert</span>&lt;<span class="title">S</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">T <span class="title">convert</span><span class="params">(S s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的java程序员，请为你想做的抽象接口，做好泛型吧。<br>我们再来看接口实现:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputDTOConvert</span> <span class="keyword">implements</span> <span class="title">DTOConvert</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(UserInputDTO userInputDTO)</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/v1/api/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">(UserInputDTO userInputDTO)</span></span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> UserInputDTOConvert().convert(userInputDTO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userService.addUser(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="review-code"><a href="#review-code" class="headerlink" title="review code"></a>review code</h3><p>如果你是一个优秀的java程序员，我相信你应该和我一样，已经数次重复review过自己的代码很多次了。<br>我们再看这个保存用户的例子，你将发现，api中返回值是有些问题的，问题就在于不应该直接返回User实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个DTO对象，我们可称它为UserOutputDTO:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserOutputDTO <span class="title">addUser</span><span class="params">(UserInputDTO userInputDTO)</span></span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> UserInputDTOConvert().convert(userInputDTO);</span><br><span class="line">User saveUserResult = userService.addUser(user);</span><br><span class="line">UserOutputDTO result = <span class="keyword">new</span> UserOutDTOConvert().convertToUser(saveUserResult);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样你的api才更健全。<br>不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的java程序员，请看一下这段我们刚刚抽象完的代码:<br>User user = new UserInputDTOConvert().convert(userInputDTO);<br>你会发现，new这样一个DTO转化对象是没有必要的，而且每一个转化对象都是由在遇到DTO转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和DTO进行聚合呢，看一下我的聚合结果:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputDTO</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">convertToUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">UserInputDTOConvert userInputDTOConvert = <span class="keyword">new</span> UserInputDTOConvert();</span><br><span class="line">User convert = userInputDTOConvert.convert(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> convert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputDTOConvert</span> <span class="keyword">implements</span> <span class="title">DTOConvert</span>&lt;<span class="title">UserInputDTO</span>,<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(UserInputDTO userInputDTO)</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后api中的转化则由:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> UserInputDTOConvert().convert(userInputDTO);</span><br><span class="line">User saveUserResult = userService.addUser(user);</span><br></pre></td></tr></table></figure></p><p>变成了:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = userInputDTO.convertToUser();</span><br><span class="line">User saveUserResult = userService.addUser(user);</span><br></pre></td></tr></table></figure></p><p>我们再DTO对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。</p><h3 id="再查工具类"><a href="#再查工具类" class="headerlink" title="再查工具类"></a>再查工具类</h3><p>再来看DTO内部转化的代码，它实现了我们自己定义的DTOConvert接口，但是这样真的就没有问题，不需要再思考了吗？<br>我觉得并不是，对于Convert这种转化语义来讲，很多工具类中都有这样的定义，这中Convert并不是业务级别上的接口定义，它只是用于普通bean之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有Convert转化语义的代码。<br>我仔细阅读了一下GUAVA的源码，发现了com.google.common.base.Convert这样的定义:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Converter</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">implements</span> <span class="title">Function</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> B <span class="title">doForward</span><span class="params">(A a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> A <span class="title">doBackward</span><span class="params">(B b)</span></span>;</span><br><span class="line"><span class="comment">//其他略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码可以了解到，GUAVA中的Convert可以完成正向转化和逆向转化，继续修改我们DTO中转化的这段代码:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputDTOConvert</span> <span class="keyword">implements</span> <span class="title">DTOConvert</span>&lt;<span class="title">UserInputDTO</span>,<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(UserInputDTO userInputDTO)</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改后:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputDTOConvert</span> <span class="keyword">extends</span> <span class="title">Converter</span>&lt;<span class="title">UserInputDTO</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> User <span class="title">doForward</span><span class="params">(UserInputDTO userInputDTO)</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> UserInputDTO <span class="title">doBackward</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">UserInputDTO userInputDTO = <span class="keyword">new</span> UserInputDTO();</span><br><span class="line">BeanUtils.copyProperties(user,userInputDTO);</span><br><span class="line"><span class="keyword">return</span> userInputDTO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的UserInputDTO和UserOutputDTO都转成UserDTO展示给大家:<br>DTO：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">convertToUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">UserDTOConvert userDTOConvert = <span class="keyword">new</span> UserDTOConvert();</span><br><span class="line">User convert = userDTOConvert.convert(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> convert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDTO <span class="title">convertFor</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">UserDTOConvert userDTOConvert = <span class="keyword">new</span> UserDTOConvert();</span><br><span class="line">UserDTO convert = userDTOConvert.reverse().convert(user);</span><br><span class="line"><span class="keyword">return</span> convert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTOConvert</span> <span class="keyword">extends</span> <span class="title">Converter</span>&lt;<span class="title">UserDTO</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> User <span class="title">doForward</span><span class="params">(UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userDTO,user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> UserDTO <span class="title">doBackward</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">UserDTO userDTO = <span class="keyword">new</span> UserDTO();</span><br><span class="line">BeanUtils.copyProperties(user,userDTO);</span><br><span class="line"><span class="keyword">return</span> userDTO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>api:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDTO <span class="title">addUser</span><span class="params">(UserDTO userDTO)</span></span>&#123;</span><br><span class="line">User user = userDTO.convertToUser();</span><br><span class="line">User saveResultUser = userService.addUser(user);</span><br><span class="line">UserDTO result = userDTO.convertFor(saveResultUser);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的DTO对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTOConvert</span> <span class="keyword">extends</span> <span class="title">Converter</span>&lt;<span class="title">UserDTO</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> User <span class="title">doForward</span><span class="params">(UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userDTO,user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> UserDTO <span class="title">doBackward</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"不支持逆向转化方法!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一下doBackward方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。<br>关于异常处理的更详细介绍，可以参考我之前的文章:如何优雅的设计java异常 ，应该可以帮你更好的理解异常。</p><h3 id="bean的验证"><a href="#bean的验证" class="headerlink" title="bean的验证"></a>bean的验证</h3><p>如果你认为我上边写的那个添加用户api写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。<br>为什么要验证<br>很多人会告诉我，如果这些api是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？<br>其实答案是这样的，我从不相信任何调用我api或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如Charles进行抓包),直接将数据传入到我的api，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！<br>“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！</p><h3 id="jsr-303验证"><a href="#jsr-303验证" class="headerlink" title="jsr 303验证"></a>jsr 303验证</h3><p>hibernate提供的jsr 303实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案!<br>再以上班的api实例进行说明，我们现在对DTO数据进行检查:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//其他代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>api验证:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDTO <span class="title">addUser</span><span class="params">(@Valid UserDTO userDTO)</span></span>&#123;</span><br><span class="line">User user = userDTO.convertToUser();</span><br><span class="line">User saveResultUser = userService.addUser(user);</span><br><span class="line">UserDTO result = userDTO.convertFor(saveResultUser);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们需要将验证结果传给前端，这种异常应该转化为一个api异常(带有错误码的异常)。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDTO <span class="title">addUser</span><span class="params">(@Valid UserDTO userDTO, BindingResult bindingResult)</span></span>&#123;</span><br><span class="line">checkDTOParams(bindingResult);</span><br><span class="line"></span><br><span class="line">User user = userDTO.convertToUser();</span><br><span class="line">User saveResultUser = userService.addUser(user);</span><br><span class="line">UserDTO result = userDTO.convertFor(saveResultUser);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkDTOParams</span><span class="params">(BindingResult bindingResult)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line"><span class="comment">//throw new 带验证码的验证错误异常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BindingResult是Spring MVC验证DTO后的一个结果集，可以参考spring 官方文档<br>检查参数后，可以抛出一个“带验证码的验证错误异常”，具体异常设计可以参考如何优雅的设计java异常</p><h3 id="拥抱lombok"><a href="#拥抱lombok" class="headerlink" title="拥抱lombok"></a>拥抱lombok</h3><p>上边的DTO代码，已经让我看的很累了，我相信读者也是一样，看到那么多的Getter和Setter方法，太烦躁了，那时候有什么方法可以简化这些呢。<br>请拥抱lombok,它会帮助我们解决一些让我们很烦躁的问题<br>去掉Setter和Getter<br>其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道lombok的存在，所以为了让读者更好的学习，我愿意写这样一个例子：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">convertToUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">UserDTOConvert userDTOConvert = <span class="keyword">new</span> UserDTOConvert();</span><br><span class="line">User convert = userDTOConvert.convert(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> convert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDTO <span class="title">convertFor</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">UserDTOConvert userDTOConvert = <span class="keyword">new</span> UserDTOConvert();</span><br><span class="line">UserDTO convert = userDTOConvert.reverse().convert(user);</span><br><span class="line"><span class="keyword">return</span> convert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTOConvert</span> <span class="keyword">extends</span> <span class="title">Converter</span>&lt;<span class="title">UserDTO</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> User <span class="title">doForward</span><span class="params">(UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">BeanUtils.copyProperties(userDTO,user);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> UserDTO <span class="title">doBackward</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"不支持逆向转化方法!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到了吧，烦人的Getter和Setter方法已经去掉了。<br>但是上边的例子根本不足以体现lombok的强大。我希望写一些网上很难查到，或者很少人进行说明的lombok的使用以及在使用时程序语义上的说明。<br>比如:@Data,@AllArgsConstructor,@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料.</p><h3 id="bean中的链式风格"><a href="#bean中的链式风格" class="headerlink" title="bean中的链式风格"></a>bean中的链式风格</h3><p>什么是链式风格？我来举个例子，看下面这个Student的bean:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细看一下set方法，这样的设置便是chain的style，调用的时候，可以这样使用:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student()</span><br><span class="line">.setAge(<span class="number">24</span>)</span><br><span class="line">.setName(<span class="string">"zs"</span>);</span><br></pre></td></tr></table></figure></p><p>相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用lombok进行改善呢，请使用 @Accessors(chain = true),看如下代码:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就完成了一个对于bean来讲很友好的链式操作。<br>静态构造方法<br>静态构造方法的语义和简化程度真的高于直接去new一个对象。比如new一个List对象，过去的使用是这样的:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>看一下guava中的创建方式:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList();</span><br></pre></td></tr></table></figure></p><p>Lists命名是一种约定(俗话说：约定优于配置)，它是指Lists是List这个类的一个工具类，那么使用List的工具类去产生List，这样的语义是不是要比直接new一个子类来的更直接一些呢，答案是肯定的，再比如如果有一个工具类叫做Maps，那你是否想到了创建Map的方法呢：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; objectObjectHashMap = Maps.newHashMap();</span><br></pre></td></tr></table></figure></p><p>好了，如果你理解了我说的语义，那么，你已经向成为java程序员更近了一步了。<br>再回过头来看刚刚的Student，很多时候，我们去写Student这个bean的时候，他会有一些必输字段，比如Student中的name字段，一般处理的方式是将name字段包装成一个构造方法，只有传入name这样的构造方法，才能创建一个Student对象。<br>接上上边的静态构造方法和必传参数的构造方法，使用lombok将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(staticName = <span class="string">"ofName"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="meta">@NonNull</span> <span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = Student.ofName(<span class="string">"zs"</span>);</span><br></pre></td></tr></table></figure></p><p>这样构建出的bean语义是否要比直接new一个含参的构造方法(包含 name的构造方法)要好很多。<br>当然，看过很多源码以后，我想相信将静态构造方法ofName换成of会先的更加简洁:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="meta">@NonNull</span> <span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = Student.of(<span class="string">"zs"</span>);</span><br></pre></td></tr></table></figure></p><p>当然他仍然是支持链式调用的:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = Student.of(<span class="string">"zs"</span>).setAge(<span class="number">24</span>);</span><br></pre></td></tr></table></figure></p><p>这样来写代码，真的很简洁，并且可读性很强。</p><h3 id="使用builder"><a href="#使用builder" class="headerlink" title="使用builder"></a>使用builder</h3><p>Builder模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。<br>今天其实要说的是一种变种的builder模式，那就是构建bean的builder模式，其实主要的思想是带着大家一起看一下lombok给我们带来了什么。<br>看一下Student这个类的原始builder状态:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setAge(age);</span><br><span class="line">student.setName(name);</span><br><span class="line"><span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用方式:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = Student.builder().name(<span class="string">"zs"</span>).age(<span class="number">24</span>).build();</span><br></pre></td></tr></table></figure></p><p>这样的builder代码，让我是在恶心难受，于是我打算用lombok重构这段代码:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用方式:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = Student.builder().name(<span class="string">"zs"</span>).age(<span class="number">24</span>).build();</span><br></pre></td></tr></table></figure></p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>正如我们所知的，在程序中调用rest接口是一个常见的行为动作，如果你和我一样使用过spring 的RestTemplate,我相信你会我和一样，对他抛出的非http状态码异常深恶痛绝。<br>所以我们考虑将RestTemplate最为底层包装器进行包装器模式的设计:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterRestTemplate</span> <span class="keyword">implements</span> <span class="title">RestOperations</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterRestTemplate</span><span class="params">(RestTemplate restTemplate)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现RestOperations所有的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再由扩展类对FilterRestTemplate进行包装扩展:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtractRestTemplate</span> <span class="keyword">extends</span> <span class="title">FilterRestTemplate</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtractRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(restTemplate);</span><br><span class="line"><span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">RestResponseDTO&lt;T&gt; <span class="title">postForEntityWithNoException</span><span class="params">(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">RestResponseDTO&lt;T&gt; restResponseDTO = <span class="keyword">new</span> RestResponseDTO&lt;T&gt;();</span><br><span class="line">ResponseEntity&lt;T&gt; tResponseEntity;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables);</span><br><span class="line">restResponseDTO.setData(tResponseEntity.getBody());</span><br><span class="line">restResponseDTO.setMessage(tResponseEntity.getStatusCode().name());</span><br><span class="line">restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR);</span><br><span class="line">restResponseDTO.setMessage(e.getMessage());</span><br><span class="line">restResponseDTO.setData(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> restResponseDTO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>包装器ExtractRestTemplate很完美的更改了异常抛出的行为，让程序更具有容错性。在这里我们不考虑ExtractRestTemplate完成的功能，让我们把焦点放在FilterRestTemplate上，“实现RestOperations所有的接口”,这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时,如下:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterRestTemplate</span> <span class="keyword">implements</span> <span class="title">RestOperations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">FilterRestTemplate</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.getForObject(url,responseType,uriVariables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.getForObject(url,responseType,uriVariables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.getForObject(url,responseType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> restTemplate.getForEntity(url,responseType,uriVariables);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他实现代码略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用lombok提供的代理注解优化了我的代码(@Delegate):<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterRestTemplate</span> <span class="keyword">implements</span> <span class="title">RestOperations</span> </span>&#123;</span><br><span class="line"><span class="meta">@Delegate</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> RestTemplate restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这几行代码完全替代上述那些冗长的代码。<br>是不是很简洁，做一个拥抱lombok的程序员吧。<br>重构需求案例项目需求<br>项目开发阶段，有一个关于下单发货的需求：如果今天下午3点前进行下单，那么发货时间是明天，如果今天下午3点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加1天为发货时间。<br>思考与重构<br>我相信这个需求看似很简单，无论怎么写都可以完成。<br>很多人可能看到这个需求，就动手开始写Calendar或Date进行计算，从而完成需求。<br>而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用Calendar或Date去解决，一定要看场景。<br>对于时间的计算我们要考虑joda-time这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。<br>请读者先考虑这个需求如何用java代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些:<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> DateTime DISTRIBUTION_TIME_SPLIT_TIME = <span class="keyword">new</span> DateTime().withTime(<span class="number">15</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> Date <span class="title">calculateDistributionTimeByOrderCreateTime</span><span class="params">(Date orderCreateTime)</span></span>&#123;</span><br><span class="line">DateTime orderCreateDateTime = <span class="keyword">new</span> DateTime(orderCreateTime);</span><br><span class="line">Date tomorrow = orderCreateDateTime.plusDays(<span class="number">1</span>).toDate();</span><br><span class="line">Date theDayAfterTomorrow = orderCreateDateTime.plusDays(<span class="number">2</span>).toDate();</span><br><span class="line"><span class="keyword">return</span> orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Date <span class="title">wrapDistributionTime</span><span class="params">(Date distributionTime)</span></span>&#123;</span><br><span class="line">DateTime currentDistributionDateTime = <span class="keyword">new</span> DateTime(distributionTime);</span><br><span class="line">DateTime plusOneDay = currentDistributionDateTime.plusDays(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> isSunday = (DateTimeConstants.SUNDAY == currentDistributionDateTime.getDayOfWeek());</span><br><span class="line"><span class="keyword">return</span> isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回，这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了3遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。</p><h3 id="提高方法"><a href="#提高方法" class="headerlink" title="提高方法"></a>提高方法</h3><p>如果你做了3年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写java的程序员，就好好的思考和重构代码吧。<br>写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的java程序员。<br>提高代码水平最好的方法就是有条理的重构！(注意：是有条理的重构)</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。<br>我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。</p><h3 id="业务驱动技术-or-技术驱动业务"><a href="#业务驱动技术-or-技术驱动业务" class="headerlink" title="业务驱动技术 or 技术驱动业务"></a>业务驱动技术 or 技术驱动业务</h3><p>业务驱动技术 or 技术驱动业务 ？ 其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个java程序员，我们应该如何判断自己所处于的位置.<br>业务驱动技术：如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。<br>技术驱动业务：如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益，比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。<br>我相信大部分人还都处于业务驱动技术的方向吧。<br>所以你既然不能驱动业务，那就请拥抱业务变化吧。</p><h3 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h3><p>一直在做java后端的项目，经常会有一些变动，我相信大家也都遇到过。<br>比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。<br>慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。<br>说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。<br>java编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计!<br>你真的优秀吗？<br>真不好意思，我取了一个这么无聊的标题。<br>国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？<br>“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？<br>答案就是:</p><pre><code>1. 多看成熟框架的源码2. 多回头看自己的代码3. 勤于重构</code></pre><p>你真的优秀吗？ 如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。<br>即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写java代码的程序员了。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>不想多讨论UML相关的知识，但是我觉得你如果真的会写java，请先学会表达自己，UML就是你说话的语言，做一名优秀的java程序员，请至少学会这两种UML图：</p><pre><code>1. 类图2. 时序图</code></pre><h3 id="clean-code"><a href="#clean-code" class="headerlink" title="clean code"></a>clean code</h3><p>我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。</p><pre><code>1. 读者可以看一下Robert C. Martin出版的《Clean Code》（代码整洁之道） 这本书2. 可以参考美团文章聊聊clean code3. 也可以看一下阿里的Java编码规范</code></pre><p>无论如何，请保持你的代码的整洁。<br>linux 基础命令<br>这点其实和会写java没有关系，但是linux很多时候确实承载运行java的容器，请学好linux的基础命令。</p><pre><code>1. 参考鸟哥的《Linux私房菜》</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>java是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。<br>本文从写java程序的小方面一直写到大方面，来阐述了如何才能写好java程序，并告诉读者们如何才能提高自身的编码水平。<br>我希望看到这篇文章的各位都能做一个优秀的java程序员。<br>坚持原创技术分享，您的支持将鼓励我继续创作！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;本文转载自一位优秀程序猿，笔者是一个务实的程序员，故本文绝非扯淡文章，文中内容都是干货，望读者看后，能有所收获。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://jasoncui.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jasoncui.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java攻城师成神之路</title>
    <link href="http://jasoncui.com/2017/02/04/Java%E6%94%BB%E5%9F%8E%E5%B8%88%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"/>
    <id>http://jasoncui.com/2017/02/04/Java攻城师成神之路/</id>
    <published>2017-02-04T13:03:04.000Z</published>
    <updated>2018-03-10T07:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>针对本文，博主最近在写<a href="http://www.hollischuang.com/archives/1001" target="_blank" rel="noopener">《成神之路系列文章》</a> ，分章分节介绍所有知识点。欢迎关注。<br></blockquote><a id="more"></a><h2 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h2><ul><li>1.1 JVM<ul><li>1.1.1. Java内存模型，Java内存管理，Java堆和栈，垃圾回收<br><a href="http://www.jcp.org/en/jsr/detail?id=133" target="_blank" rel="noopener">http://www.jcp.org/en/jsr/detail?id=133</a><br><a href="http://ifeve.com/jmm-faq/" target="_blank" rel="noopener">http://ifeve.com/jmm-faq/</a></li><li>1.1.2. 了解JVM各种参数及调优</li><li>1.1.3. 学习使用Java工具<br>jps, jstack, jmap, jconsole, jinfo, jhat, javap, …<br><a href="http://kenai.com/projects/btrace" target="_blank" rel="noopener">http://kenai.com/projects/btrace</a><br><a href="http://www.crashub.org/" target="_blank" rel="noopener">http://www.crashub.org/</a><br><a href="https://github.com/taobao/TProfiler" target="_blank" rel="noopener">https://github.com/taobao/TProfiler</a><br><a href="https://github.com/CSUG/HouseMD" target="_blank" rel="noopener">https://github.com/CSUG/HouseMD</a><br><a href="http://wiki.cyclopsgroup.org/jmxterm" target="_blank" rel="noopener">http://wiki.cyclopsgroup.org/jmxterm</a><br><a href="https://github.com/jlusdy/TBJMap" target="_blank" rel="noopener">https://github.com/jlusdy/TBJMap</a></li><li>1.1.4. 学习Java诊断工具<br><a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">http://www.eclipse.org/mat/</a><br><a href="http://visualvm.java.net/oqlhelp.html" target="_blank" rel="noopener">http://visualvm.java.net/oqlhelp.html</a></li><li>1.1.5. 自己编写各种outofmemory，stackoverflow程序<br>HeapOutOfMemory<br>Young OutOfMemory<br>MethodArea OutOfMemory<br>ConstantPool OutOfMemory<br>DirectMemory OutOfMemory<br>Stack OutOfMemory Stack OverFlow</li><li>1.1.6. 使用工具尝试解决以下问题，并写下总结<br>当一个Java程序响应很慢时如何查找问题 当一个Java程序频繁FullGC时如何解决问题，如何查看垃圾回收日志 当一个Java应用发生OutOfMemory时该如何解决，年轻代、年老代、永久代解决办法不同，导致原因也不同</li><li>1.1.7. 参考资料<br><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jvms/se7/html/</a><br><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/</a><br><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a><br><a href="http://www.guru99.com/java-virtual-machine-jvm.html" target="_blank" rel="noopener">http://www.guru99.com/java-virtual-machine-jvm.html</a></li></ul></li><li>1.2. Java基础知识<ul><li>1.2.1. 阅读源代码<br>java.lang.String java.lang.Integer<code>java.lang.Long java.lang.Enum java.math.BigDecimal java.lang.ThreadLocal java.lang.ClassLoader &amp; java.net.URLClassLoader java.util.ArrayList &amp; java.util.LinkedList</code> java.util.HashMap &amp; java.util.LinkedHashMap &amp; java.util.TreeMap java.util.HashSet &amp; java.util.LinkedHashSet &amp; java.util.TreeSet</li><li>1.2.2. 熟悉Java中各种变量类型</li><li>1.2.3. 熟悉Java String的使用，熟悉String的各种函数</li><li>1.2.4. 熟悉Java中各种关键字</li><li>1.2.5. 学会使用List，Map，Stack，Queue，Set<br>上述数据结构的遍历 上述数据结构的使用场景 Java实现对Array/List排序 java.uti.Arrays.sort() java.util.Collections.sort() Java实现对List去重 Java实现对List去重，并且需要保留数据原始的出现顺序 Java实现最近最少使用cache，用LinkedHashMap</li><li>1.2.6. Java IO&amp;Java NIO，并学会使用<br>java.io.<em> java.nio.</em> nio和reactor设计模式 文件编码，字符集</li><li>1.2.7. Java反射与javassist<br>反射与工厂模式 java.lang.reflect.*</li><li>1.2.8. Java序列化<br>java.io. Serializable 什么是序列化，为什么序列化 序列化与单例模式 google序列化protobuf</li><li>1.2.9. 虚引用，弱引用，软引用<br>java.lang.ref.* 实验这些引用的回收</li><li>1.2.10. 熟悉Java系统属性<br>java.util.Properties</li><li>1.2.11. 熟悉Annotation用法<br>java.lang.annotation.*</li><li>1.2.12. JMS<br>javax.jms.*</li><li>1.2.13. JMX<br>java.lang.management.<em> javax.management.</em></li><li>1.2.14. 泛型和继承，泛型和擦除</li><li>1.2.15. 自动拆箱装箱与字节码</li><li>1.2.16. 实现Callback</li><li>1.2.17. java.lang.Void类使用</li><li>1.2.18. Java Agent，premain函数<br>java.lang.instrument</li><li>1.2.19. 单元测试<br>Junit，<a href="http://junit.org/" target="_blank" rel="noopener">http://junit.org/</a><br>Jmockit，<a href="https://code.google.com/p/jmockit/" target="_blank" rel="noopener">https://code.google.com/p/jmockit/</a><br>djUnit，<a href="http://works.dgic.co.jp/djunit/" target="_blank" rel="noopener">http://works.dgic.co.jp/djunit/</a></li><li>1.2.20. Java实现通过正则表达式提取一段文本中的电子邮件，并将@替换为#输出<br>java.lang.util.regex.*</li><li>1.2.21. 学习使用常用的Java工具库<br>commons.lang, commons.*… guava-libraries netty</li><li>1.2.22. 什么是API&amp;SPI<br><a href="http://en.wikipedia.org/wiki/Application_programming_interface" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Application_programming_interface</a><br><a href="http://en.wikipedia.org/wiki/Service_provider_interface" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Service_provider_interface</a></li><li>1.2.23. 参考资料<br>JDK src.zip 源代码<br><a href="http://openjdk.java.net/" target="_blank" rel="noopener">http://openjdk.java.net/</a><br><a href="http://commons.apache.org/" target="_blank" rel="noopener">http://commons.apache.org/</a><br><a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="noopener">https://code.google.com/p/guava-libraries/</a><br><a href="http://netty.io/" target="_blank" rel="noopener">http://netty.io/</a><br><a href="http://stackoverflow.com/questions/2954372/difference-between-spi-and-api" target="_blank" rel="noopener">http://stackoverflow.com/questions/2954372/difference-between-spi-and-api</a><br><a href="http://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java" target="_blank" rel="noopener">http://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java</a></li></ul></li><li>1.3. Java并发编程<ul><li>1.3.1. 阅读源代码，并学会使用<br>java.lang.Thread java.lang.Runnable java.util.concurrent.Callable java.util.concurrent.locks.ReentrantLock java.util.concurrent.locks.ReentrantReadWriteLock java.util.concurrent.atomic.Atomic* java.util.concurrent.Semaphore java.util.concurrent.CountDownLatch java.util.concurrent.CyclicBarrier java.util.concurrent.ConcurrentHashMap java.util.concurrent.Executors</li><li>1.3.2. 学习使用线程池，自己设计线程池需要注意什么</li><li>1.3.3. 锁什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么 在并发编程中锁的意义是什么</li><li>1.3.4. synchronized的作用是什么，synchronized和lock</li><li>1.3.5. sleep和wait</li><li>1.3.6. wait和notify</li><li>1.3.7. 写一个死锁的程序</li><li>1.3.8. 什么是守护线程，守护线程和非守护线程的区别以及用法</li><li>1.3.9. volatile关键字的理解<br>C++ volatile关键字和Java volatile关键字 happens-before语义 编译器指令重排和CPU指令重排<br><a href="http://en.wikipedia.org/wiki/Memory_ordering" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Memory_ordering</a><br><a href="http://en.wikipedia.org/wiki/Volatile_variable" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Volatile_variable</a><br><a href="http://preshing.com/20130702/the-happens-before-relation/" target="_blank" rel="noopener">http://preshing.com/20130702/the-happens-before-relation/</a></li><li>1.3.10. 以下代码是不是线程安全？为什么？如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？<br>publicclassSample{privatestaticint count =0;publicstaticvoid increment(){<br>count++;}}</li><li>1.3.11. 解释一下下面两段代码的差别<br>// 代码1publicclassSample{privatestaticint count =0;synchronizedpublicstaticvoid increment(){<br>count++;}}// 代码2publicclassSample{privatestaticAtomicInteger count =newAtomicInteger(0);publicstaticvoid increment(){<br>count.getAndIncrement();}}</li><li>1.3.12. 参考资料<br><a href="http://book.douban.com/subject/10484692/" target="_blank" rel="noopener">http://book.douban.com/subject/10484692/</a><br><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="noopener">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a><h2 id="二、-进阶篇"><a href="#二、-进阶篇" class="headerlink" title="二、 进阶篇"></a>二、 进阶篇</h2></li></ul></li><li>2.1. Java底层知识<ul><li>2.1.1. 学习了解字节码、class文件格式<br><a href="http://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Java_class_file</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Java_bytecode</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</a><br><a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank" rel="noopener">http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/</a><br><a href="http://asm.ow2.org/" target="_blank" rel="noopener">http://asm.ow2.org/</a></li><li>2.1.2. 写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）<br>如Java源代码：<br>publicstaticvoid main(String[] args){int i =0;<br>i +=1;<br>i *=1;System.out.println(i);}<br>编译后读取class文件输出以下代码：<br>publicstaticvoid main(java.lang.String[]);Code:Stack=2,Locals=2,Args_size=10: iconst_0<br>1: istore_1<br>2: iinc 1,15: iload_1<br>6: iconst_1<br>7: imul<br>8: istore_1<br>9: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;12: iload_1<br>13: invokevirtual #3; //Method java/io/PrintStream.println:(I)V16:returnLineNumberTable:<br>line 4:0<br>line 5:2<br>line 6:5<br>line 7:9<br>line 8:16</li><li>2.1.3. CPU缓存，L1，L2，L3和伪共享<br><a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches/" target="_blank" rel="noopener">http://duartes.org/gustavo/blog/post/intel-cpu-caches/</a><br><a href="http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html" target="_blank" rel="noopener">http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html</a></li><li>2.1.4. 什么是尾递归</li><li>2.1.5. 熟悉位运算<br>用位运算实现加、减、乘、除、取余</li><li>2.1.6. 参考资料<br><a href="http://book.douban.com/subject/1138768/" target="_blank" rel="noopener">http://book.douban.com/subject/1138768/</a><br><a href="http://book.douban.com/subject/6522893/" target="_blank" rel="noopener">http://book.douban.com/subject/6522893/</a><br><a href="http://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Java_class_file</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Java_bytecode</a><br><a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings</a></li></ul></li><li>2.2. 设计模式<ul><li>2.2.1. 实现AOP<br>CGLIB和InvocationHandler的区别 <a href="http://cglib.sourceforge.net/" target="_blank" rel="noopener">http://cglib.sourceforge.net/</a><br>动态代理模式 Javassist实现AOP <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_blank" rel="noopener">http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/</a><br>ASM实现AOP <a href="http://asm.ow2.org/" target="_blank" rel="noopener">http://asm.ow2.org/</a></li><li>2.2.2. 使用模板方法设计模式和策略设计模式实现IOC2.2.3. 不用synchronized和lock，实现线程安全的单例模式2.2.4. nio和reactor设计模式2.2.5. 参考资料<br><a href="http://asm.ow2.org/" target="_blank" rel="noopener">http://asm.ow2.org/</a><br><a href="http://cglib.sourceforge.net/" target="_blank" rel="noopener">http://cglib.sourceforge.net/</a><br><a href="http://www.javassist.org/" target="_blank" rel="noopener">http://www.javassist.org/</a></li></ul></li><li>2.3. 网络编程知识<ul><li>2.3.1. Java RMI，Socket，HttpClient</li><li>2.3.2. 用Java写一个简单的静态文件的HTTP服务器<br>实现客户端缓存功能，支持返回304 实现可并发下载一个文件 使用线程池处理客户端请求 使用nio处理客户端请求 支持简单的rewrite规则 上述功能在实现的时候需要满足“开闭原则”</li><li>2.3.3. 了解nginx和apache服务器的特性并搭建一个对应的服务器<br><a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a><br><a href="http://httpd.apache.org/" target="_blank" rel="noopener">http://httpd.apache.org/</a></li><li>2.3.4. 用Java实现FTP、SMTP协议</li><li>2.3.5. 什么是CDN？如果实现？DNS起到什么作用？<br>搭建一个DNS服务器 搭建一个 Squid 或 Apache Traffic Server 服务器 <a href="http://www.squid-cache.org/" target="_blank" rel="noopener">http://www.squid-cache.org/</a> <a href="http://trafficserver.apache.org/" target="_blank" rel="noopener">http://trafficserver.apache.org/</a> <a href="http://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Domain_Name_System</a></li><li>2.3.6. 参考资料<br><a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc2616.txt</a><br><a href="http://tools.ietf.org/rfc/rfc5321.txt" target="_blank" rel="noopener">http://tools.ietf.org/rfc/rfc5321.txt</a><br><a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Open/closed_principle</a></li></ul></li><li>2.4. 框架知识<br>spring，spring mvc，阅读主要源码 ibatis，阅读主要源码 用spring和ibatis搭建java server</li><li>2.5. 应用服务器知识<br>熟悉使用jboss，<a href="https://www.jboss.org/overview/" target="_blank" rel="noopener">https://www.jboss.org/overview/</a> 熟悉使用tomcat，<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a> 熟悉使用jetty，<a href="http://www.eclipse.org/jetty/" target="_blank" rel="noopener">http://www.eclipse.org/jetty/</a><h2 id="三、-高级篇"><a href="#三、-高级篇" class="headerlink" title="三、 高级篇"></a>三、 高级篇</h2></li><li>3.1. 编译原理知识<ul><li>3.1.1. 用Java实现以下表达式解析并返回结果（语法和Oracle中的select sysdate-1 from dual类似）<br>sysdate<br>sysdate -1<br>sysdate -1/24<br>sysdate -1/(12*2)</li><li>3.1.2. 实现对一个List通过DSL筛选<br>QList&lt;Map&lt;String,Object&gt;&gt; mapList =newQList&lt;Map&lt;String,Object&gt;&gt;;<br>mapList.add({“name”:”hatter test”});<br>mapList.add({“id”:-1,”name”:”hatter test”});<br>mapList.add({“id”:0,”name”:”hatter test”});<br>mapList.add({“id”:1,”name”:”test test”});<br>mapList.add({“id”:2,”name”:”hatter test”});<br>mapList.add({“id”:3,”name”:”test hatter”});<br>mapList.query(“id is not null and id &gt; 0 and name like ‘%hatter%’”);<br>要求返回列表中匹配的对象，即最后两个对象；</li><li>3.1.3. 用Java实现以下程序（语法和变量作用域处理都和JavaScript类似）：<br>代码：<br>var a =1;var b =2;var c =function(){var a =3;<br>println(a);<br>println(b);};<br>c();<br>println(a);<br>println(b);<br>输出：<br>3212</li><li>3.1.4. 参考资料<br><a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Abstract_syntax_tree</a> <a href="https://javacc.java.net/" target="_blank" rel="noopener">https://javacc.java.net/</a> <a href="http://www.antlr.org/" target="_blank" rel="noopener">http://www.antlr.org/</a></li></ul></li><li>3.2. 操作系统知识<br>Ubuntu Centos 使用linux，熟悉shell脚本</li><li>3.3. 数据存储知识<ul><li>3.3.1. 关系型数据库<br>MySQL 如何看执行计划 如何搭建MySQL主备 binlog是什么 Derby，H2，PostgreSQL SQLite</li><li>3.3.2. NoSQL<br>Cache Redis Memcached Leveldb Bigtable HBase Cassandra Mongodb 图数据库 neo4j</li><li>3.3.3. 参考资料<br><a href="http://db-engines.com/en/ranking" target="_blank" rel="noopener">http://db-engines.com/en/ranking</a><br><a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a><br><a href="https://code.google.com/p/leveldb/" target="_blank" rel="noopener">https://code.google.com/p/leveldb/</a><br><a href="http://hbase.apache.org/" target="_blank" rel="noopener">http://hbase.apache.org/</a><br><a href="http://cassandra.apache.org/" target="_blank" rel="noopener">http://cassandra.apache.org/</a><br><a href="http://www.mongodb.org/" target="_blank" rel="noopener">http://www.mongodb.org/</a><br><a href="http://www.neo4j.org/" target="_blank" rel="noopener">http://www.neo4j.org/</a></li></ul></li><li>3.4. 大数据知识<ul><li>3.4.1. Zookeeper，在linux上部署zk</li><li>3.4.2. Solr，Lucene，ElasticSearch<br>在linux上部署solr，solrcloud，，新增、删除、查询索引</li><li>3.4.3. Storm，流式计算，了解Spark，S4<br>在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。</li><li>3.4.4. Hadoop，离线计算<br>Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件<br>MapReduce：部署JobTracker，TaskTracker，编写mr job<br>Hive：部署hive，书写hive sql，得到结果<br>Presto：类hive，不过比hive快，非常值得学习</li><li>3.4.5. 分布式日志收集flume，kafka，logstash</li><li>3.4.6. 数据挖掘，mahout</li><li>3.4.7. 参考资料<br><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">http://zookeeper.apache.org/</a><br><a href="https://lucene.apache.org/solr/" target="_blank" rel="noopener">https://lucene.apache.org/solr/</a><br><a href="https://github.com/nathanmarz/storm/wiki" target="_blank" rel="noopener">https://github.com/nathanmarz/storm/wiki</a><br><a href="http://hadoop.apache.org/" target="_blank" rel="noopener">http://hadoop.apache.org/</a><br><a href="http://prestodb.io/" target="_blank" rel="noopener">http://prestodb.io/</a><br><a href="http://flume.apache.org/" target="_blank" rel="noopener">http://flume.apache.org/</a><br><a href="http://logstash.net/" target="_blank" rel="noopener">http://logstash.net/</a><br><a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a><br><a href="http://mahout.apache.org/" target="_blank" rel="noopener">http://mahout.apache.org/</a></li></ul></li><li>3.5. 网络安全知识<ul><li>3.5.1. 什么是DES、AES</li><li>3.5.2. 什么是RSA、DSA</li><li>3.5.3. 什么是MD5，SHA1</li><li>3.5.4. 什么是SSL、TLS，为什么HTTPS相对比较安全</li><li>3.5.5. 什么是中间人攻击、如果避免中间人攻击</li><li>3.5.6. 什么是DOS、DDOS、CC攻击</li><li>3.5.7. 什么是CSRF攻击</li><li>3.5.8. 什么是CSS攻击</li><li>3.5.9. 什么是SQL注入攻击</li><li>3.5.10. 什么是Hash碰撞拒绝服务攻击</li><li>3.5.11. 了解并学习下面几种增强安全的技术<br><a href="http://www.openauthentication.org/" target="_blank" rel="noopener">http://www.openauthentication.org/</a><br>HOTP <a href="http://www.ietf.org/rfc/rfc4226.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc4226.txt</a><br>TOTP <a href="http://tools.ietf.org/rfc/rfc6238.txt" target="_blank" rel="noopener">http://tools.ietf.org/rfc/rfc6238.txt</a><br>OCRA <a href="http://tools.ietf.org/rfc/rfc6287.txt" target="_blank" rel="noopener">http://tools.ietf.org/rfc/rfc6287.txt</a><br><a href="http://en.wikipedia.org/wiki/Salt_(cryptography)" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Salt_(cryptography)</a></li><li>3.5.12. 用openssl签一个证书部署到apache或nginx</li><li>3.5.13. 参考资料<br><a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Cryptographic_hash_function</a><br><a href="http://en.wikipedia.org/wiki/Block_cipher" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Block_cipher</a><br><a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Public-key_cryptography</a><br><a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Transport_Layer_Security</a><br><a href="http://www.openssl.org/" target="_blank" rel="noopener">http://www.openssl.org/</a><br><a href="https://code.google.com/p/google-authenticator/" target="_blank" rel="noopener">https://code.google.com/p/google-authenticator/</a><h2 id="四、-扩展篇"><a href="#四、-扩展篇" class="headerlink" title="四、 扩展篇"></a>四、 扩展篇</h2></li></ul></li><li>4.1. 相关知识<ul><li>4.1.1. 云计算，分布式，高可用，可扩展</li><li>4.1.2. 虚拟化<br><a href="https://linuxcontainers.org/" target="_blank" rel="noopener">https://linuxcontainers.org/</a><br><a href="http://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">http://www.linux-kvm.org/page/Main_Page</a><br><a href="http://www.xenproject.org/" target="_blank" rel="noopener">http://www.xenproject.org/</a><br><a href="https://www.docker.io/" target="_blank" rel="noopener">https://www.docker.io/</a></li><li>4.1.3. 监控<br><a href="http://www.nagios.org/" target="_blank" rel="noopener">http://www.nagios.org/</a><br><a href="http://ganglia.info/" target="_blank" rel="noopener">http://ganglia.info/</a></li><li>4.1.4. 负载均衡<br><a href="http://www.linuxvirtualserver.org/" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/</a></li><li>4.1.5. 学习使用git<br><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br><a href="https://git.oschina.net/" target="_blank" rel="noopener">https://git.oschina.net/</a></li><li>4.1.6. 学习使用maven<br><a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a></li><li>4.1.7. 学习使用gradle<br><a href="http://www.gradle.org/" target="_blank" rel="noopener">http://www.gradle.org/</a></li><li>4.1.8. 学习一个小语种语言<br>Groovy Scala LISP, Common LISP, Schema, Clojure R Julia Lua Ruby</li><li>4.1.9. 尝试了解编码的本质<br>了解以下概念 ASCII, ISO-8859-1 GB2312, GBK, GB18030 Unicode, UTF-8 不使用 String.getBytes() 等其他工具类/函数完成下面功能<br>publicstaticvoid main(String[] args)throwsIOException{String str =”Hello, 我们是中国人。”;byte[] utf8Bytes = toUTF8Bytes(str);FileOutputStream fos =newFileOutputStream(“f.txt”);<br>fos.write(utf8Bytes);<br>fos.close();}publicstaticbyte[] toUTF8Bytes(String str){returnnull;// TODO}<br>想一下上面的程序能不能写一个转GBK的？ 写个程序自动判断一个文件是哪种编码</li><li>4.1.10. 尝试了解时间的本质<br>时区 &amp; 冬令时、夏令时 <a href="http://en.wikipedia.org/wiki/Time_zone" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Time_zone</a> <a href="ftp://ftp.iana.org/tz/data/asia" target="_blank" rel="noopener">ftp://ftp.iana.org/tz/data/asia</a> <a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E6%99%82%E5%8D%80</a><br>闰年 <a href="http://en.wikipedia.org/wiki/Leap_year" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Leap_year</a><br>闰秒 <a href="ftp://ftp.iana.org/tz/data/leapseconds" target="_blank" rel="noopener">ftp://ftp.iana.org/tz/data/leapseconds</a><br>System.currentTimeMillis() 返回的时间是什么</li><li>4.1.11. 参考资料<br><a href="http://git-scm.com/" target="_blank" rel="noopener">http://git-scm.com/</a><br><a href="http://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/UTF-8</a><br><a href="http://www.iana.org/time-zones" target="_blank" rel="noopener">http://www.iana.org/time-zones</a></li></ul></li><li>4.2. 扩展学习<ul><li>4.2.1. JavaScript知识</li><li>4.2.1.1. 什么是prototype<br>修改代码，使程序输出“1 3 5”： <a href="http://jsfiddle.net/Ts7Fk/" target="_blank" rel="noopener">http://jsfiddle.net/Ts7Fk/</a></li><li>4.2.1.2. 什么是闭包<br>看一下这段代码，并解释一下为什么按Button1时没有alert出“This is button: 1”，如何修改： <a href="http://jsfiddle.net/FDPj3/1/" target="_blank" rel="noopener">http://jsfiddle.net/FDPj3/1/</a></li><li>4.2.1.3. 了解并学习一个JS框架<br>jQuery ExtJS ArgularJS</li><li>4.2.1.4. 写一个Greasemonkey插件<br><a href="http://en.wikipedia.org/wiki/Greasemonkey" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Greasemonkey</a></li><li>4.2.1.5. 学习node.js<br><a href="http://nodejs.org/" target="_blank" rel="noopener">http://nodejs.org/</a></li></ul></li><li>4.2.2. 学习html5<br>ArgularJS，<a href="https://docs.angularjs.org/api" target="_blank" rel="noopener">https://docs.angularjs.org/api</a><ul><li>4.2.3. 参考资料<br><a href="http://www.ecmascript.org/" target="_blank" rel="noopener">http://www.ecmascript.org/</a><br><a href="http://jsfiddle.net/" target="_blank" rel="noopener">http://jsfiddle.net/</a><br><a href="http://jsbin.com/" target="_blank" rel="noopener">http://jsbin.com/</a><br><a href="http://runjs.cn/" target="_blank" rel="noopener">http://runjs.cn/</a><br><a href="http://userscripts.org/" target="_blank" rel="noopener">http://userscripts.org/</a><h2 id="五、-推荐书籍"><a href="#五、-推荐书籍" class="headerlink" title="五、 推荐书籍"></a>五、 推荐书籍</h2>《深入Java虚拟机》<br>《深入理解Java虚拟机》<br>《Effective Java》<br>《七周七语言》<br>《七周七数据》<br>《Hadoop技术内幕》<br>《Hbase In Action》<br>《Mahout In Action》<br>《这就是搜索引擎》<br>《Solr In Action》<br>《深入分析Java Web技术内幕》<br>《大型网站技术架构》<br>《高性能MySQL》<br>《算法导论》<br>《计算机程序设计艺术》<br>《代码大全》<br>《JavaScript权威指南》</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;针对本文，博主最近在写&lt;a href=&quot;http://www.hollischuang.com/archives/1001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《成神之路系列文章》&lt;/a&gt; ，分章分节介绍所有知识点。欢迎关注。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://jasoncui.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://jasoncui.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式接口幂等性设计</title>
    <link href="http://jasoncui.com/2016/12/19/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://jasoncui.com/2016/12/19/分布式接口幂等性设计/</id>
    <published>2016-12-19T06:07:36.000Z</published>
    <updated>2018-06-01T03:23:01.855Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>    关于分布式系统中接口幂等性设计的介绍<br></blockquote><a id="more"></a><h2 id="一、幂等性定义"><a href="#一、幂等性定义" class="headerlink" title="一、幂等性定义"></a>一、幂等性定义</h2><p>HTTP/1.1规范中幂等性的定义是：<br>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.<br>从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。<br>更多介绍请阅读<a href="http://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html" target="_blank" rel="noopener">理解HTTP幂等性</a></p><h2 id="二、接口中幂等性设计"><a href="#二、接口中幂等性设计" class="headerlink" title="二、接口中幂等性设计"></a>二、接口中幂等性设计</h2><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a><em>查询操作</em></h4><p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的，select是天然的幂等操作。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><em>删除操作</em></h4><p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)。 </p><h4 id="唯一索引，防止新增脏数据"><a href="#唯一索引，防止新增脏数据" class="headerlink" title="唯一索引，防止新增脏数据"></a><em>唯一索引，防止新增脏数据</em></h4><p>比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。</p><h4 id="token机制，防止页面重复提交"><a href="#token机制，防止页面重复提交" class="headerlink" title="token机制，防止页面重复提交"></a><em>token机制，防止页面重复提交</em></h4><p>业务要求：<br>页面的数据只能被点击提交一次<br>发生原因：<br>由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交<br>解决办法：<br>集群环境：采用token加redis（redis单线程的，处理需要排队）<br>单JVM环境：采用token加redis或token加jvm内存<br>处理流程： </p><ol><li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间 </li><li>提交后后台校验token，同时删除token，生成新的token返回<br>token特点：<br>要申请，一次有效性，可以限流<br>注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用 </li></ol><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><em>悲观锁</em></h4><p>获取数据的时候加锁获取<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_xxx <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'xxx'</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure></p><p>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的<br>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用 </p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><em>乐观锁</em></h4><p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 </p><p>乐观锁的实现方式多种多样可以通过version或者其他状态条件： </p><ol><li><p>通过版本号实现 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_xxx <span class="keyword">set</span> <span class="keyword">name</span>=#<span class="keyword">name</span>#,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">version</span>=#<span class="keyword">version</span>#</span><br></pre></td></tr></table></figure></li><li><p>通过条件限制 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_xxx <span class="keyword">set</span> avai_amount=avai_amount-#subAmount# <span class="keyword">where</span> avai_amount-#subAmount# &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol><p>要求：quality-#subQuality# &gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高 </p><p>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_xxx <span class="keyword">set</span> <span class="keyword">name</span>=#<span class="keyword">name</span>#,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=#<span class="keyword">id</span># <span class="keyword">and</span> <span class="keyword">version</span>=#<span class="keyword">version</span># </span><br><span class="line"><span class="keyword">update</span> table_xxx <span class="keyword">set</span> avai_amount=avai_amount-#subAmount# <span class="keyword">where</span> <span class="keyword">id</span>=#<span class="keyword">id</span># <span class="keyword">and</span> avai_amount-#subAmount# &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><em>分布式锁</em></h4><p>还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。 </p><p>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供) </p><h4 id="select-insert"><a href="#select-insert" class="headerlink" title="select + insert"></a><em>select + insert</em></h4><p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了<br>注意：核心高并发流程不要用这种方法 </p><h4 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a><em>状态机幂等</em></h4><p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。 </p><p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助 </p><h4 id="对外提供接口的api如何保证幂等"><a href="#对外提供接口的api如何保证幂等" class="headerlink" title="对外提供接口的api如何保证幂等"></a><em>对外提供接口的api如何保证幂等</em></h4><p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号<br>source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求) </p><p><strong>重点：</strong><br>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。 </p><blockquote><p>参考阅读</p><ul><li><a href="http://825635381.iteye.com/blog/2276077" target="_blank" rel="noopener">高并发的核心技术-幂等性实现方案</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;    关于分布式系统中接口幂等性设计的介绍&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://jasoncui.com/categories/Java/"/>
    
    
      <category term="幂等性" scheme="http://jasoncui.com/tags/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS原理</title>
    <link href="http://jasoncui.com/2016/12/01/HTTPS%E5%8E%9F%E7%90%86/"/>
    <id>http://jasoncui.com/2016/12/01/HTTPS原理/</id>
    <published>2016-12-01T01:45:07.000Z</published>
    <updated>2018-03-10T07:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>为了保证这些隐私数据能加密传输，网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br></blockquote><a id="more"></a><h2 id="一、HTTPS原理"><a href="#一、HTTPS原理" class="headerlink" title="一、HTTPS原理"></a>一、HTTPS原理</h2><p>为了保证这些隐私数据能加密传输，网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：<br>1.浏览器将自己支持的一套加密规则发送给网站。<br>2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。<br>3.获得网站证书之后浏览器要做以下工作：<br>a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。<br>b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。<br>c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。<br>4.网站接收浏览器发来的数据之后要做以下的操作：<br>a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。<br>b) 使用密码加密一段握手消息，发送给浏览器。<br>5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。<br>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：<br>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，3DES<br>HASH算法：MD5，SHA1，SHA256<br>其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p><blockquote><p>参考阅读</p><ul><li><a href="http://www.guokr.com/post/114121/" target="_blank" rel="noopener">HTTPS那些事（一）HTTPS原理</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;为了保证这些隐私数据能加密传输，网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="基础" scheme="http://jasoncui.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Http" scheme="http://jasoncui.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Docker Logging via EFK (Elasticsearch + Fluentd + Kibana) Stack with Docker Compose</title>
    <link href="http://jasoncui.com/2016/11/24/Docker%20Logging%20via%20EFK/"/>
    <id>http://jasoncui.com/2016/11/24/Docker Logging via EFK/</id>
    <published>2016-11-24T13:02:44.000Z</published>
    <updated>2018-03-10T07:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>This article explains how to collect Docker logs to EFK (Elasticsearch + Fluentd + Kibana) stack. The example uses Docker Compose for setting up multiple containers.<br></blockquote><a id="more"></a><hr><p>Elasticsearch is an open source search engine known for its ease of use. Kibana is an open source Web UI that makes Elasticsearch user friendly for marketers, engineers and data scientists alike.<br>By combining these three tools EFK (Elasticsearch + Fluentd + Kibana) we get a scalable, flexible, easy to use log collection and analytics pipeline. In this article, we will set up 4 containers, each includes:</p><pre><code>* Apache HTTP Server* Fluentd* Elasticsearch* Kibana</code></pre><p>All of httpd’s logs will be ingested into Elasticsearch + Kibana, via Fluentd.<br>Table of Contents</p><pre><code>* Prerequisites: Docker* Step 0: prepare docker-compose.yml * Step 1: Prepare Fluentd image with your Config + Plugin * Step 2: Start Containers * Step 3: Generate httpd Access Logs * Step 4: Confirm Logs from Kibana* Conclusion* Learn More</code></pre><h3 id="Prerequisites-Docker"><a href="#Prerequisites-Docker" class="headerlink" title="Prerequisites: Docker"></a>Prerequisites: Docker</h3><p>Please download and install Docker / Docker Compose. Well, that’s it :)</p><blockquote><p><a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">Docker Installation</a></p></blockquote><h3 id="Step-0-prepare-docker-compose-yml"><a href="#Step-0-prepare-docker-compose-yml" class="headerlink" title="Step 0: prepare docker-compose.yml"></a>Step 0: prepare docker-compose.yml</h3><p>First, please prepare docker-compose.yml for Docker Compose.<br>Docker Compose is a tool for defining and running multi-container Docker applications.<br>With the YAML file below, you can create and start all the services (in this case, Apache, Fluentd, Elasticsearch, Kibana) by one command.<br>  <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'2'</span></span><br><span class="line">services:</span><br><span class="line">web:</span><br><span class="line">image: httpd</span><br><span class="line">ports:</span><br><span class="line">- <span class="string">"80:80"</span></span><br><span class="line">links:</span><br><span class="line">- fluentd</span><br><span class="line">logging:</span><br><span class="line">driver: <span class="string">"fluentd"</span></span><br><span class="line">options:</span><br><span class="line">fluentd-address: localhost:<span class="number">24224</span></span><br><span class="line">tag: httpd.access</span><br><span class="line"></span><br><span class="line">fluentd:</span><br><span class="line">build: ./fluentd</span><br><span class="line">volumes:</span><br><span class="line">- ./fluentd/conf:/fluentd/etc</span><br><span class="line">links:</span><br><span class="line">- <span class="string">"elasticsearch"</span></span><br><span class="line">ports:</span><br><span class="line">- <span class="string">"24224:24224"</span></span><br><span class="line">- <span class="string">"24224:24224/udp"</span></span><br><span class="line"></span><br><span class="line">elasticsearch:</span><br><span class="line">image: elasticsearch</span><br><span class="line"><span class="keyword">expose</span>:</span><br><span class="line">- <span class="number">9200</span></span><br><span class="line">ports:</span><br><span class="line">- <span class="string">"9200:9200"</span></span><br><span class="line"></span><br><span class="line">kibana:</span><br><span class="line">image: kibana</span><br><span class="line">links:</span><br><span class="line">- <span class="string">"elasticsearch"</span></span><br><span class="line">ports:</span><br><span class="line">- <span class="string">"5601:5601"</span></span><br></pre></td></tr></table></figure></p><p>logging section (check Docker Compose documentation) of web container specifies Docker Fluentd Logging Driver as a default container logging driver. All of the logs from web container will be automatically forwarded to host:port specified by fluentd-address.</p><h3 id="Step-1-Prepare-Fluentd-image-with-your-Config-Plugin"><a href="#Step-1-Prepare-Fluentd-image-with-your-Config-Plugin" class="headerlink" title="Step 1: Prepare Fluentd image with your Config + Plugin"></a>Step 1: Prepare Fluentd image with your Config + Plugin</h3><p>Then, please prepare fluentd/Dockerfile with the following content, to use Fluentd’s official Docker image and additionally install Elasticsearch plugin.<br>  <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fluentd/Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> fluent/fluentd:v0.<span class="number">12</span>-debian</span><br><span class="line"><span class="keyword">RUN</span> ["gem", "install", "fluent-plugin-elasticsearch", "--no-rdoc", "--no-ri", "--version", "1.9.2"]</span><br></pre></td></tr></table></figure></p><p>Then, please prepare Fluentd’s configuration file fluentd/conf/fluent.conf. in_forward plugin is used for receive logs from Docker logging driver, and out_elasticsearch is for forwarding logs to Elasticsearch.<br>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#fluentd/<span class="keyword">conf</span>/fluent.<span class="keyword">conf</span></span><br><span class="line"><span class="symbol">&lt;source&gt;</span></span><br><span class="line">@type forward</span><br><span class="line">port <span class="number">24224</span></span><br><span class="line">bind <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">&lt;/<span class="keyword">source</span>&gt;</span><br><span class="line">&lt;<span class="keyword">match</span> *.**&gt;</span><br><span class="line">@type <span class="keyword">copy</span></span><br><span class="line"><span class="symbol">&lt;store&gt;</span></span><br><span class="line">@type elasticsearch</span><br><span class="line">host elasticsearch</span><br><span class="line">port <span class="number">9200</span></span><br><span class="line">logstash_format true</span><br><span class="line">logstash_prefix fluentd</span><br><span class="line">logstash_dateformat %Y%<span class="keyword">m</span>%d</span><br><span class="line">include_tag_key true</span><br><span class="line">type_name access_log</span><br><span class="line">tag_key @log_name</span><br><span class="line">flush_interval <span class="number">1</span>s</span><br><span class="line">&lt;/store&gt;</span><br><span class="line"><span class="symbol">&lt;store&gt;</span></span><br><span class="line">@type stdout</span><br><span class="line">&lt;/store&gt;</span><br><span class="line">&lt;/<span class="keyword">match</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Step-2-Start-Containers"><a href="#Step-2-Start-Containers" class="headerlink" title="Step 2: Start Containers"></a>Step 2: Start Containers</h3><p>Let’s start all of the containers, with just one command.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure></p><p>You can check to see if 4 containers are running by docker ps command.<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line"><span class="number">2</span>d28323d77a3 httpd <span class="string">"httpd-foreground"</span> About an hour ago Up <span class="number">43</span> seconds <span class="number">0.0</span>.0.0:<span class="number">80</span>-&gt;<span class="number">80</span>/tcp dockercomposeefk_web_1</span><br><span class="line">a1b15a7210f6 dockercomposeefk_fluentd <span class="string">"/bin/sh -c 'exec ..."</span> About an hour ago Up <span class="number">45</span> seconds <span class="number">5140</span>/tcp, <span class="number">0.0</span>.0.0:<span class="number">24224</span>-&gt;<span class="number">24224</span>/tcp, <span class="number">0.0</span>.0.0:<span class="number">24224</span>-&gt;<span class="number">24224</span>/udp dockercomposeefk_fluentd_1</span><br><span class="line"><span class="number">01e43</span>b191cc1 kibana <span class="string">"/docker-entrypoin..."</span> About an hour ago Up <span class="number">45</span> seconds <span class="number">0.0</span>.0.0:<span class="number">5601</span>-&gt;<span class="number">5601</span>/tcp dockercomposeefk_kibana_1</span><br><span class="line">b7b439415898 elasticsearch <span class="string">"/docker-entrypoin..."</span> About an hour ago Up <span class="number">50</span> seconds <span class="number">0.0</span>.0.0:<span class="number">9200</span>-&gt;<span class="number">9200</span>/tcp, <span class="number">9300</span>/tcp dockercomposeefk_elasticsearch_1</span><br></pre></td></tr></table></figure></p><h3 id="Step-3-Generate-httpd-Access-Logs"><a href="#Step-3-Generate-httpd-Access-Logs" class="headerlink" title="Step 3: Generate httpd Access Logs"></a>Step 3: Generate httpd Access Logs</h3><p>Let’s access to httpd to generate some access logs. curl command is always your friend.<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ repeat <span class="number">10</span> curl http:<span class="comment">//localhost:80/</span></span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Step-4-Confirm-Logs-from-Kibana"><a href="#Step-4-Confirm-Logs-from-Kibana" class="headerlink" title="Step 4: Confirm Logs from Kibana"></a>Step 4: Confirm Logs from Kibana</h3><p>Please go to <a href="http://localhost:5601/" target="_blank" rel="noopener">http://localhost:5601/</a> with your browser. Then, you need to set up the index name pattern for Kibana. Please specify fluentd-* to Index name or pattern and press Create button.<br>Then, go to Discover tab to seek for the logs. As you can see, logs are properly collected into Elasticsearch + Kibana, via Fluentd.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>This article explains how to collect logs from Apache to EFK (Elasticsearch + Fluentd + Kibana). The example code is available in this repository.</p><pre><code>* https://github.com/kzk/docker-compose-efk</code></pre><h3 id="Learn-More"><a href="#Learn-More" class="headerlink" title="Learn More"></a>Learn More</h3><blockquote><p><a href="https://docs.fluentd.org/v0.12/articles/architecture" target="_blank" rel="noopener">Fluentd Architecture</a><br><a href="https://docs.fluentd.org/v0.12/articles/quickstart" target="_blank" rel="noopener">Fluentd Get Started</a><br><a href="http://www.fluentd.org/download" target="_blank" rel="noopener">Downloading Fluentd</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;This article explains how to collect Docker logs to EFK (Elasticsearch + Fluentd + Kibana) stack. The example uses Docker Compose for setting up multiple containers.&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://jasoncui.com/categories/Docker/"/>
    
    
      <category term="Docker日志" scheme="http://jasoncui.com/tags/Docker%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>经纬度坐标转换</title>
    <link href="http://jasoncui.com/2016/11/24/%E7%BB%8F%E7%BA%AC%E5%BA%A6%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <id>http://jasoncui.com/2016/11/24/经纬度坐标转换/</id>
    <published>2016-11-24T13:02:44.000Z</published>
    <updated>2018-03-10T07:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>利用Geotools工具转换经纬度坐标为需要的投影坐标。<br></blockquote><a id="more"></a><h2 id="名词扫盲"><a href="#名词扫盲" class="headerlink" title="名词扫盲"></a>名词扫盲</h2><h3 id="EPSG"><a href="#EPSG" class="headerlink" title="EPSG"></a>EPSG</h3><p>EPSG：European Petroleum Survey Group (EPSG)， <a href="http://www.epsg.org/，它成立于1986年，并在2005年重组为OGP" target="_blank" rel="noopener">http://www.epsg.org/，它成立于1986年，并在2005年重组为OGP</a>(Internation Association of Oil &amp; Gas Producers)，它负责维护并发布坐标参照系统的数据集参数，以及坐标转换描述，该数据集被广泛接受并使用，通过一个Web发布平台进行分发，同时提供了微软Acess数据库的存储文件，通过SQL 脚本文件，mySQL, Oracle 和PostgreSQL等数据库也可使用。<br>目前已有的椭球体，投影坐标系等不同组合都对应着不同的ID号，这个号在EPSG中被称为EPSG code，它代表特定的椭球体、单位、地理坐标系或投影坐标系等信息。</p><h3 id="SRID"><a href="#SRID" class="headerlink" title="SRID"></a>SRID</h3><p>SRID：OGC标准中的参数SRID，也是指的空间参考系统的ID，与EPSG一致；WMS 1.1.1以前用SRS参数（空间参考系）表示坐标系统，WMS1.3开始用CRS参数（坐标参考系统）来表示。<br>    A Spatial Reference System Identifier(SRID) is a unique value used to unambiguously identify projected, unprojected, and local spatial coordinate system definitions. These coordinate systems form the heart of all GIS applications.<br>    Virtually all major spatial vendors have created their own SRID implementation or refer to those of an authority, such as the European Petroleum Survey Group (EPSG). (NOTE: As of 2005 the EPSG SRID values are now maintained by the International Association of Oil &amp; Gas Producers (OGP) Surveying &amp; Positioning Committee).<br>以OGC请求为例：<br><a href="http://localhost/IS/WebServices/wms.ashx?map=World&amp;SERVICE=WMS&amp;REQUEST=GetMap&amp;LAYERS=&amp;STYLES=&amp;SRS=EPSG:4326&amp;BBOX=-3,44,10,53&amp;WIDTH=600&amp;HEIGHT=300&amp;FORMAT=image/gif&amp;BGCOLOR=&amp;VERSION=1.1.1" target="_blank" rel="noopener">http://localhost/IS/WebServices/wms.ashx?map=World&amp;SERVICE=WMS&amp;REQUEST=GetMap&amp;LAYERS=&amp;STYLES=&amp;SRS=EPSG:4326&amp;BBOX=-3,44,10,53&amp;WIDTH=600&amp;HEIGHT=300&amp;FORMAT=image/gif&amp;BGCOLOR=&amp;VERSION=1.1.1</a><br>SRS=EPSG:4326代表地理坐标系WGS1984</p><h3 id="WKT"><a href="#WKT" class="headerlink" title="WKT"></a>WKT</h3><p>空间参考系统的文字描述；无论是参考椭球、基准面、投影方式、坐标单位等，都有相应 的EPSG值表示。</p><p>举例：<br>Beijing 1954地理坐标系，高斯–克吕格投影（横轴等角切圆柱投影）<br>下面为投影相关信息：<br>投影方式 Gauss_Kruger<br>中央经线 75.000000<br>原点纬线 0.000000<br>标准纬线(1) 0.000000<br>标准纬线(2) 0.000000<br>水平偏移量 13500000.000000<br>垂直偏移量 0.000000<br>比例因子 1.000000<br>方位角   0.000000<br>第一点经线 0.000000<br>第二点经线 0.000000<br>地理坐标系 GCS_Beijing_1954<br>大地参照系 D_Beijing_1954<br>参考椭球体 Krasovsky_1940<br>椭球长半轴 6378245.000000<br>椭球扁率 0.0033523299<br>本初子午线 0.000000</p><p>WKT形式表示该投影坐标系：<br>PROJCS[“Gauss_Kruger”,<br>GEOGCS[“GCS_Beijing_1954”,<br>   DATUM[“D_Beijing_1954”,<br>    SPHEROID[“Krasovsky_1940”,6378245.000000,298.299997264589]]<br>   ]<br>PEIMEM[“Greenwich”,0]<br>UNIT[“degree”,0.0174532925199433]//地理单位：0.0174532925199433代表与米之间的转换<br>],<br>PROJECTION[“Gauss_Kruger”],<br>PARAMETER[“False_Easting”,13500000.000000],<br>PARAMETER[“False_Northing”,0],<br>PARAMETER[“Central_Meridian”,75.000000],<br>PARAMETER[“Scale_Factor”,1.0],<br>PARAMETER[“Latitude_Of_Origin”,0.0],<br>UNIT[“Meter”,1.0]] ;</p><h2 id="GeoTools"><a href="#GeoTools" class="headerlink" title="GeoTools"></a>GeoTools</h2><p>GeoTools is an open source Java library that provides tools for geospatial data.</p><p>本文主要介绍利用GeoTools进行坐标系转换，将经纬度坐标转为投影坐标。<br>maven引入依赖包</p><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.geotools&lt;/groupId&gt;        &lt;artifactId&gt;gt-referencing&lt;/artifactId&gt;        &lt;version&gt;16.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.geotools&lt;/groupId&gt;        &lt;artifactId&gt;gt-epsg-wkt&lt;/artifactId&gt;        &lt;version&gt;16.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.geotools&lt;/groupId&gt;        &lt;artifactId&gt;gt-api&lt;/artifactId&gt;        &lt;version&gt;16.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.geotools&lt;/groupId&gt;        &lt;artifactId&gt;gt-opengis&lt;/artifactId&gt;        &lt;version&gt;16.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.geotools&lt;/groupId&gt;        &lt;artifactId&gt;gt-metadata&lt;/artifactId&gt;        &lt;version&gt;16.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.vividsolutions&lt;/groupId&gt;        &lt;artifactId&gt;jts&lt;/artifactId&gt;        &lt;version&gt;1.13&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.googlecode.efficient-java-matrix-library&lt;/groupId&gt;        &lt;artifactId&gt;ejml&lt;/artifactId&gt;        &lt;version&gt;0.25&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;eu.agrosense.apps&lt;/groupId&gt;        &lt;artifactId&gt;launcher&lt;/artifactId&gt;        &lt;version&gt;14.02-beta&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>核心代码</p><pre><code>public static double[] convert(double lon, double lat)        throws FactoryException, MismatchedDimensionException, TransformException {    // 传入原始的经纬度坐标    Coordinate sourceCoord = new Coordinate(lon, lat);    GeometryFactory geoFactory = new GeometryFactory();    Point sourcePoint = geoFactory.createPoint(sourceCoord);    // 这里是以OGC WKT形式定义的是World Mercator投影，网页地图一般使用该投影    final String strWKTMercator = &quot;PROJCS[\&quot;World_Mercator\&quot;,&quot;            + &quot;GEOGCS[\&quot;GCS_WGS_1984\&quot;,&quot;            + &quot;DATUM[\&quot;WGS_1984\&quot;,&quot;            + &quot;SPHEROID[\&quot;WGS_1984\&quot;,6378137,298.257223563]],&quot;            + &quot;PRIMEM[\&quot;Greenwich\&quot;,0],&quot;            + &quot;UNIT[\&quot;Degree\&quot;,0.017453292519943295]],&quot;            + &quot;PROJECTION[\&quot;Mercator_1SP\&quot;],&quot;            + &quot;PARAMETER[\&quot;False_Easting\&quot;,0],&quot;            + &quot;PARAMETER[\&quot;False_Northing\&quot;,0],&quot;            + &quot;PARAMETER[\&quot;Central_Meridian\&quot;,0],&quot;            + &quot;PARAMETER[\&quot;latitude_of_origin\&quot;,0],&quot;            + &quot;UNIT[\&quot;Meter\&quot;,1]]&quot;;    CoordinateReferenceSystem mercatroCRS = CRS.parseWKT(strWKTMercator);    // 做投影转换，将WCG84坐标转换成世界墨卡托投影转    MathTransform transform = CRS.findMathTransform(DefaultGeographicCRS.WGS84, mercatroCRS);    Point targetPoint = (Point) JTS.transform(sourcePoint, transform);    // 返回转换以后的X和Y坐标    double[] targetCoord = {targetPoint.getX(), targetPoint.getY()};    return targetCoord;}</code></pre><p>上述方法中引用的是OGC WKT形式定义的world mercator投影，更多WKT可查看<a href="http://spatialreference.org/" target="_blank" rel="noopener">http://spatialreference.org/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;br&gt;利用Geotools工具转换经纬度坐标为需要的投影坐标。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随记" scheme="http://jasoncui.com/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="坐标转换" scheme="http://jasoncui.com/tags/%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>吭书吧</title>
    <link href="http://jasoncui.com/2016/10/14/%E6%88%91%E7%9A%84%E8%AF%BB%E4%B9%A6/"/>
    <id>http://jasoncui.com/2016/10/14/我的读书/</id>
    <published>2016-10-14T03:25:06.000Z</published>
    <updated>2018-02-23T10:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">书山有路勤为径</blockquote><a id="more"></a><h3 id="未读书单"><a href="#未读书单" class="headerlink" title="未读书单"></a>未读书单</h3><h4 id="《Spring-Boot实战》"><a href="#《Spring-Boot实战》" class="headerlink" title="《Spring Boot实战》"></a>《Spring Boot实战》</h4><h4 id="《JavaEE开发的颠覆者-Spring-Boot实战-完整版》"><a href="#《JavaEE开发的颠覆者-Spring-Boot实战-完整版》" class="headerlink" title="《JavaEE开发的颠覆者 Spring Boot实战  完整版》"></a>《JavaEE开发的颠覆者 Spring Boot实战  完整版》</h4><h4 id="《Spring技术内幕：深入解析Spring架构与设计原理-第2版-》"><a href="#《Spring技术内幕：深入解析Spring架构与设计原理-第2版-》" class="headerlink" title="《Spring技术内幕：深入解析Spring架构与设计原理(第2版)》"></a>《Spring技术内幕：深入解析Spring架构与设计原理(第2版)》</h4><h4 id="《Gradle-User-Guide》"><a href="#《Gradle-User-Guide》" class="headerlink" title="《Gradle User Guide》"></a>《Gradle User Guide》</h4><h4 id="《JHipster》"><a href="#《JHipster》" class="headerlink" title="《JHipster》"></a>《JHipster》</h4><h3 id="已读书单"><a href="#已读书单" class="headerlink" title="已读书单"></a>已读书单</h3><pre><code>坚持每天读书，写下读书笔记。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;书山有路勤为径&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书" scheme="http://jasoncui.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://jasoncui.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
